
C:\Users\debra\AppData\Local\arduino\sketches\66718F68928DA0F874EAE0236ADBD92E/strandtest_wheel.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
../../../../crt1/gcrt1.S:61
   0:	3d c0       	rjmp	.+122    	; 0x7c <__dtors_end>
   2:	00 00       	nop
../../../../crt1/gcrt1.S:67
   4:	6c c0       	rjmp	.+216    	; 0xde <__bad_interrupt>
   6:	00 00       	nop
../../../../crt1/gcrt1.S:68
   8:	6a c0       	rjmp	.+212    	; 0xde <__bad_interrupt>
   a:	00 00       	nop
../../../../crt1/gcrt1.S:69
   c:	68 c0       	rjmp	.+208    	; 0xde <__bad_interrupt>
   e:	00 00       	nop
../../../../crt1/gcrt1.S:70
  10:	66 c0       	rjmp	.+204    	; 0xde <__bad_interrupt>
  12:	00 00       	nop
../../../../crt1/gcrt1.S:71
  14:	64 c0       	rjmp	.+200    	; 0xde <__bad_interrupt>
  16:	00 00       	nop
../../../../crt1/gcrt1.S:72
  18:	62 c0       	rjmp	.+196    	; 0xde <__bad_interrupt>
  1a:	00 00       	nop
../../../../crt1/gcrt1.S:73
  1c:	60 c0       	rjmp	.+192    	; 0xde <__bad_interrupt>
  1e:	00 00       	nop
../../../../crt1/gcrt1.S:74
  20:	5e c0       	rjmp	.+188    	; 0xde <__bad_interrupt>
  22:	00 00       	nop
../../../../crt1/gcrt1.S:75
  24:	5c c0       	rjmp	.+184    	; 0xde <__bad_interrupt>
  26:	00 00       	nop
../../../../crt1/gcrt1.S:76
  28:	5a c0       	rjmp	.+180    	; 0xde <__bad_interrupt>
  2a:	00 00       	nop
../../../../crt1/gcrt1.S:77
  2c:	58 c0       	rjmp	.+176    	; 0xde <__bad_interrupt>
  2e:	00 00       	nop
../../../../crt1/gcrt1.S:78
  30:	56 c0       	rjmp	.+172    	; 0xde <__bad_interrupt>
  32:	00 00       	nop
../../../../crt1/gcrt1.S:79
  34:	54 c0       	rjmp	.+168    	; 0xde <__bad_interrupt>
  36:	00 00       	nop
../../../../crt1/gcrt1.S:80
  38:	52 c0       	rjmp	.+164    	; 0xde <__bad_interrupt>
  3a:	00 00       	nop
../../../../crt1/gcrt1.S:81
  3c:	50 c0       	rjmp	.+160    	; 0xde <__bad_interrupt>
  3e:	00 00       	nop
../../../../crt1/gcrt1.S:82
  40:	4e c0       	rjmp	.+156    	; 0xde <__bad_interrupt>
  42:	00 00       	nop
../../../../crt1/gcrt1.S:83
  44:	4c c0       	rjmp	.+152    	; 0xde <__bad_interrupt>
  46:	00 00       	nop
../../../../crt1/gcrt1.S:84
  48:	4a c0       	rjmp	.+148    	; 0xde <__bad_interrupt>
  4a:	00 00       	nop
../../../../crt1/gcrt1.S:85
  4c:	48 c0       	rjmp	.+144    	; 0xde <__bad_interrupt>
  4e:	00 00       	nop
../../../../crt1/gcrt1.S:86
  50:	46 c0       	rjmp	.+140    	; 0xde <__bad_interrupt>
  52:	00 00       	nop
../../../../crt1/gcrt1.S:87
  54:	44 c0       	rjmp	.+136    	; 0xde <__bad_interrupt>
  56:	00 00       	nop
../../../../crt1/gcrt1.S:88
  58:	42 c0       	rjmp	.+132    	; 0xde <__bad_interrupt>
  5a:	00 00       	nop
../../../../crt1/gcrt1.S:89
  5c:	40 c0       	rjmp	.+128    	; 0xde <__bad_interrupt>
  5e:	00 00       	nop
../../../../crt1/gcrt1.S:90
  60:	3e c0       	rjmp	.+124    	; 0xde <__bad_interrupt>
  62:	00 00       	nop
../../../../crt1/gcrt1.S:91
  64:	e5 c2       	rjmp	.+1482   	; 0x630 <__vector_25>
  66:	00 00       	nop
../../../../crt1/gcrt1.S:92
  68:	3a c0       	rjmp	.+116    	; 0xde <__bad_interrupt>
  6a:	00 00       	nop
../../../../crt1/gcrt1.S:93
  6c:	38 c0       	rjmp	.+112    	; 0xde <__bad_interrupt>
  6e:	00 00       	nop
../../../../crt1/gcrt1.S:94
  70:	36 c0       	rjmp	.+108    	; 0xde <__bad_interrupt>
  72:	00 00       	nop
../../../../crt1/gcrt1.S:95
  74:	34 c0       	rjmp	.+104    	; 0xde <__bad_interrupt>
	...

00000078 <__ctors_start>:
__trampolines_start():
  78:	40 04       	cpc	r4, r0

0000007a <__ctors_end>:
__dtors_start():
  7a:	92 04       	cpc	r9, r2

0000007c <__dtors_end>:
__dtors_end():
../../../../crt1/gcrt1.S:230
  7c:	11 24       	eor	r1, r1
../../../../crt1/gcrt1.S:231
  7e:	1f be       	out	0x3f, r1	; 63
../../../../crt1/gcrt1.S:232
  80:	cf ef       	ldi	r28, 0xFF	; 255
../../../../crt1/gcrt1.S:234
  82:	cd bf       	out	0x3d, r28	; 61
../../../../crt1/gcrt1.S:236
  84:	df e3       	ldi	r29, 0x3F	; 63
../../../../crt1/gcrt1.S:237
  86:	de bf       	out	0x3e, r29	; 62

00000088 <_initThreeStuff()>:
_Z15_initThreeStuffv():
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/main.cpp:104

  /* Minimum: Reset if we wound up here through malfunction - this relies on user clearing the  *
   * register on startup, which is rarely done in Arduino land.                                 */
  void __attribute__((weak)) init_reset_flags() ;
  void __attribute__((weak)) init_reset_flags() {
    uint8_t flags = RSTCTRL.RSTFR;
  88:	80 91 40 00 	lds	r24, 0x0040	; 0x800040 <digital_pin_to_bit_mask+0x7f7414>
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/main.cpp:105
    RSTCTRL.RSTFR = flags;
  8c:	80 93 40 00 	sts	0x0040, r24	; 0x800040 <digital_pin_to_bit_mask+0x7f7414>
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/main.cpp:106
    if (flags == 0) {
  90:	81 11       	cpse	r24, r1
  92:	05 c0       	rjmp	.+10     	; 0x9e <_initThreeStuff()+0x16>
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/main.cpp:107
      _PROTECTED_WRITE(RSTCTRL.SWRR, 1);
  94:	98 ed       	ldi	r25, 0xD8	; 216
  96:	21 e0       	ldi	r18, 0x01	; 1
  98:	94 bf       	out	0x34, r25	; 52
  9a:	20 93 41 00 	sts	0x0041, r18	; 0x800041 <digital_pin_to_bit_mask+0x7f7415>
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/main.cpp:109
    }
    GPIOR0 = flags;
  9e:	8c bb       	out	0x1c, r24	; 28

000000a0 <__do_clear_bss>:
__do_clear_bss():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2441
  a0:	24 e3       	ldi	r18, 0x34	; 52
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
  a2:	a6 e0       	ldi	r26, 0x06	; 6
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
  a4:	b4 e3       	ldi	r27, 0x34	; 52
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
  a6:	01 c0       	rjmp	.+2      	; 0xaa <.do_clear_bss_start>

000000a8 <.do_clear_bss_loop>:
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2446
  a8:	1d 92       	st	X+, r1

000000aa <.do_clear_bss_start>:
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2448
  aa:	a4 32       	cpi	r26, 0x24	; 36
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
  ac:	b2 07       	cpc	r27, r18
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
  ae:	e1 f7       	brne	.-8      	; 0xa8 <.do_clear_bss_loop>

000000b0 <__do_copy_data>:
__do_copy_data():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2409
  b0:	14 e3       	ldi	r17, 0x34	; 52
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2410
  b2:	a0 e0       	ldi	r26, 0x00	; 0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2411
  b4:	b4 e3       	ldi	r27, 0x34	; 52
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2412
  b6:	e8 e3       	ldi	r30, 0x38	; 56
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2413
  b8:	fc e0       	ldi	r31, 0x0C	; 12
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2414
  ba:	02 c0       	rjmp	.+4      	; 0xc0 <__do_copy_data+0x10>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2417
  bc:	05 90       	lpm	r0, Z+
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2422
  be:	0d 92       	st	X+, r0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2424
  c0:	a6 30       	cpi	r26, 0x06	; 6
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2425
  c2:	b1 07       	cpc	r27, r17
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2426
  c4:	d9 f7       	brne	.-10     	; 0xbc <__do_copy_data+0xc>

000000c6 <__do_global_ctors>:
__do_global_ctors():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2466
  c6:	10 e0       	ldi	r17, 0x00	; 0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2467
  c8:	cd e3       	ldi	r28, 0x3D	; 61
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2468
  ca:	d0 e0       	ldi	r29, 0x00	; 0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2472
  cc:	03 c0       	rjmp	.+6      	; 0xd4 <__do_global_ctors+0xe>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2474
  ce:	21 97       	sbiw	r28, 0x01	; 1
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2480
  d0:	fe 01       	movw	r30, r28
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2481
  d2:	54 d4       	rcall	.+2216   	; 0x97c <__tablejump2__>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2483
  d4:	cc 33       	cpi	r28, 0x3C	; 60
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2484
  d6:	d1 07       	cpc	r29, r17
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2489
  d8:	d1 f7       	brne	.-12     	; 0xce <__do_global_ctors+0x8>
../../../../crt1/gcrt1.S:314
  da:	c6 d2       	rcall	.+1420   	; 0x668 <main>
../../../../crt1/gcrt1.S:315
  dc:	89 c5       	rjmp	.+2834   	; 0xbf0 <__do_global_dtors>

000000de <__bad_interrupt>:
__vector_22():
  de:	90 cf       	rjmp	.-224    	; 0x0 <__vectors>

000000e0 <Adafruit_NeoPixel::setPixelColor(unsigned int, unsigned long) [clone .constprop.5]>:
_ZN17Adafruit_NeoPixel13setPixelColorEjm.constprop.5():
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:3389
  @param   n  Pixel index, starting from 0.
  @param   c  32-bit color value. Most significant byte is white (for RGBW
              pixels) or ignored (for RGB pixels), next is red, then green,
              and least significant byte is blue.
*/
void Adafruit_NeoPixel::setPixelColor(uint16_t n, uint32_t c) {
  e0:	8f 92       	push	r8
  e2:	9f 92       	push	r9
  e4:	af 92       	push	r10
  e6:	bf 92       	push	r11
  e8:	cf 92       	push	r12
  ea:	df 92       	push	r13
  ec:	ef 92       	push	r14
  ee:	ff 92       	push	r15
  f0:	cf 93       	push	r28
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:3390
  if (n < numLEDs) {
  f2:	20 91 0c 34 	lds	r18, 0x340C	; 0x80340c <strip+0x2>
  f6:	30 91 0d 34 	lds	r19, 0x340D	; 0x80340d <strip+0x3>
  fa:	82 17       	cp	r24, r18
  fc:	93 07       	cpc	r25, r19
  fe:	e8 f5       	brcc	.+122    	; 0x17a <__EEPROM_REGION_LENGTH__+0x7a>
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:3391
    uint8_t *p, r = (uint8_t)(c >> 16), g = (uint8_t)(c >> 8), b = (uint8_t)c;
 100:	4b 01       	movw	r8, r22
 102:	aa 24       	eor	r10, r10
 104:	bb 24       	eor	r11, r11
 106:	c8 2d       	mov	r28, r8
 108:	c5 2e       	mov	r12, r21
 10a:	d6 2e       	mov	r13, r22
 10c:	e7 2e       	mov	r14, r23
 10e:	ff 24       	eor	r15, r15
 110:	bc 2d       	mov	r27, r12
 112:	a4 2f       	mov	r26, r20
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:3392
    if (brightness) { // See notes in setBrightness()
 114:	20 91 12 34 	lds	r18, 0x3412	; 0x803412 <strip+0x8>
 118:	22 23       	and	r18, r18
 11a:	61 f0       	breq	.+24     	; 0x134 <__EEPROM_REGION_LENGTH__+0x34>
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:3393
      r = (r * brightness) >> 8;
 11c:	82 9e       	mul	r8, r18
 11e:	40 01       	movw	r8, r0
 120:	11 24       	eor	r1, r1
 122:	c9 2d       	mov	r28, r9
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:3394
      g = (g * brightness) >> 8;
 124:	2c 9d       	mul	r18, r12
 126:	60 01       	movw	r12, r0
 128:	11 24       	eor	r1, r1
 12a:	bd 2d       	mov	r27, r13
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:3395
      b = (b * brightness) >> 8;
 12c:	24 9f       	mul	r18, r20
 12e:	f0 01       	movw	r30, r0
 130:	11 24       	eor	r1, r1
 132:	af 2f       	mov	r26, r31
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:3397
    }
    if (wOffset == rOffset) {
 134:	e0 91 18 34 	lds	r30, 0x3418	; 0x803418 <strip+0xe>
 138:	e0 90 13 34 	lds	r14, 0x3413	; 0x803413 <strip+0x9>
 13c:	f0 90 14 34 	lds	r15, 0x3414	; 0x803414 <strip+0xa>
 140:	30 91 15 34 	lds	r19, 0x3415	; 0x803415 <strip+0xb>
 144:	e3 13       	cpse	r30, r19
 146:	23 c0       	rjmp	.+70     	; 0x18e <__EEPROM_REGION_LENGTH__+0x8e>
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:3398
      p = &pixels[n * 3];
 148:	9c 01       	movw	r18, r24
 14a:	22 0f       	add	r18, r18
 14c:	33 1f       	adc	r19, r19
 14e:	82 0f       	add	r24, r18
 150:	93 1f       	adc	r25, r19
 152:	8e 0d       	add	r24, r14
 154:	9f 1d       	adc	r25, r15
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:3404
    } else {
      p = &pixels[n * 4];
      uint8_t w = (uint8_t)(c >> 24);
      p[wOffset] = brightness ? ((w * brightness) >> 8) : w;
    }
    p[rOffset] = r;
 156:	e0 91 15 34 	lds	r30, 0x3415	; 0x803415 <strip+0xb>
 15a:	e8 0f       	add	r30, r24
 15c:	f9 2f       	mov	r31, r25
 15e:	f1 1d       	adc	r31, r1
 160:	c0 83       	st	Z, r28
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:3405
    p[gOffset] = g;
 162:	e0 91 16 34 	lds	r30, 0x3416	; 0x803416 <strip+0xc>
 166:	e8 0f       	add	r30, r24
 168:	f9 2f       	mov	r31, r25
 16a:	f1 1d       	adc	r31, r1
 16c:	b0 83       	st	Z, r27
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:3406
    p[bOffset] = b;
 16e:	20 91 17 34 	lds	r18, 0x3417	; 0x803417 <strip+0xd>
 172:	82 0f       	add	r24, r18
 174:	91 1d       	adc	r25, r1
 176:	fc 01       	movw	r30, r24
 178:	a0 83       	st	Z, r26
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:3408
  }
}
 17a:	cf 91       	pop	r28
 17c:	ff 90       	pop	r15
 17e:	ef 90       	pop	r14
 180:	df 90       	pop	r13
 182:	cf 90       	pop	r12
 184:	bf 90       	pop	r11
 186:	af 90       	pop	r10
 188:	9f 90       	pop	r9
 18a:	8f 90       	pop	r8
 18c:	08 95       	ret
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:3400
      b = (b * brightness) >> 8;
    }
    if (wOffset == rOffset) {
      p = &pixels[n * 3];
    } else {
      p = &pixels[n * 4];
 18e:	88 0f       	add	r24, r24
 190:	99 1f       	adc	r25, r25
 192:	88 0f       	add	r24, r24
 194:	99 1f       	adc	r25, r25
 196:	8e 0d       	add	r24, r14
 198:	9f 1d       	adc	r25, r15
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:3401
      uint8_t w = (uint8_t)(c >> 24);
 19a:	47 2f       	mov	r20, r23
 19c:	55 27       	eor	r21, r21
 19e:	66 27       	eor	r22, r22
 1a0:	77 27       	eor	r23, r23
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:3402
      p[wOffset] = brightness ? ((w * brightness) >> 8) : w;
 1a2:	22 23       	and	r18, r18
 1a4:	49 f0       	breq	.+18     	; 0x1b8 <__EEPROM_REGION_LENGTH__+0xb8>
 1a6:	30 e0       	ldi	r19, 0x00	; 0
 1a8:	24 9f       	mul	r18, r20
 1aa:	70 01       	movw	r14, r0
 1ac:	25 9f       	mul	r18, r21
 1ae:	f0 0c       	add	r15, r0
 1b0:	34 9f       	mul	r19, r20
 1b2:	f0 0c       	add	r15, r0
 1b4:	11 24       	eor	r1, r1
 1b6:	4f 2d       	mov	r20, r15
 1b8:	e8 0f       	add	r30, r24
 1ba:	f9 2f       	mov	r31, r25
 1bc:	f1 1d       	adc	r31, r1
 1be:	40 83       	st	Z, r20
 1c0:	ca cf       	rjmp	.-108    	; 0x156 <__EEPROM_REGION_LENGTH__+0x56>

000001c2 <micros>:
micros():
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:508
    #else /* TCA */
      uint8_t ticks;
    #endif
    uint8_t flags;
    /* Save current state and disable interrupts */
    uint8_t oldSREG = SREG;
 1c2:	9f b7       	in	r25, 0x3f	; 63
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:509
    cli(); /* INTERRUPTS OFF */
 1c4:	f8 94       	cli
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:519
      TCD0.CTRLE = TCD_SCAPTUREA_bm;
      while (!(TCD0.STATUS & TCD_CMDRDY_bm)); // wait for sync - should be only one iteration of this loop
      flags = TCD0.INTFLAGS;
      ticks = TCD0.CAPTUREA;
    #else
      ticks = _timer->CNT;
 1c6:	e0 91 9a 0a 	lds	r30, 0x0A9A	; 0x800a9a <digital_pin_to_bit_mask+0x7f7e6e>
 1ca:	f0 91 9b 0a 	lds	r31, 0x0A9B	; 0x800a9b <digital_pin_to_bit_mask+0x7f7e6f>
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:520
      flags = _timer->INTFLAGS;
 1ce:	80 91 96 0a 	lds	r24, 0x0A96	; 0x800a96 <digital_pin_to_bit_mask+0x7f7e6a>
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:530
     * doesn't matter.
     * Get current number of overflows and timer count */
    #if !((defined(MILLIS_USE_TIMERB0) || defined(MILLIS_USE_TIMERB1) || defined(MILLIS_USE_TIMERB2) || defined(MILLIS_USE_TIMERB3) || defined(MILLIS_USE_TIMERB4)))
      overflows = timingStruct.timer_overflow_count;
    #else
      overflows = timingStruct.timer_millis;
 1d2:	20 91 06 34 	lds	r18, 0x3406	; 0x803406 <__data_end>
 1d6:	30 91 07 34 	lds	r19, 0x3407	; 0x803407 <__data_end+0x1>
 1da:	40 91 08 34 	lds	r20, 0x3408	; 0x803408 <__data_end+0x2>
 1de:	50 91 09 34 	lds	r21, 0x3409	; 0x803409 <__data_end+0x3>
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:533
    #endif
    /* Turn interrupts back on, assuming they were on when micros was called. */
    SREG = oldSREG; /* INTERRUPTS ON */
 1e2:	9f bf       	out	0x3f, r25	; 63
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:540
      if ((flags & TCD_OVF_bm) && (ticks < 0x07)) {
    #elif defined(MILLIS_USE_TIMERA0)
      ticks = (TIME_TRACKING_TIMER_PERIOD) - ticks;
      if ((flags & TCA_SPLIT_HUNF_bm) && (ticks < 0x04)) {
    #else // timerb
      if ((flags & TCB_CAPT_bm) && !(ticks & 0xFF00)) {
 1e4:	80 ff       	sbrs	r24, 0
 1e6:	08 c0       	rjmp	.+16     	; 0x1f8 <micros+0x36>
 1e8:	cf 01       	movw	r24, r30
 1ea:	88 27       	eor	r24, r24
 1ec:	89 2b       	or	r24, r25
 1ee:	21 f4       	brne	.+8      	; 0x1f8 <micros+0x36>
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:545
    #endif
    #if ((defined(MILLIS_USE_TIMERB0) || defined(MILLIS_USE_TIMERB1) || defined(MILLIS_USE_TIMERB2) || defined(MILLIS_USE_TIMERB3) || defined(MILLIS_USE_TIMERB4)) && !(F_CPU > 2000000UL))
      overflows +=2;
    #else
      overflows++;
 1f0:	2f 5f       	subi	r18, 0xFF	; 255
 1f2:	3f 4f       	sbci	r19, 0xFF	; 255
 1f4:	4f 4f       	sbci	r20, 0xFF	; 255
 1f6:	5f 4f       	sbci	r21, 0xFF	; 255
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:835
      // powers of 2  - and a catchall for parts without dedicated implementations. It gives wrong results, but
      // it also doesn't take forever like doing division would.
      #elif (F_CPU  == 32000000UL || F_CPU > 24000000UL)
        microseconds = overflows * 1000 + (ticks >> 4);
      #elif (F_CPU  == 16000000UL || F_CPU > 12000000UL)
        microseconds = overflows * 1000 + (ticks >> 3);
 1f8:	a8 ee       	ldi	r26, 0xE8	; 232
 1fa:	b3 e0       	ldi	r27, 0x03	; 3
 1fc:	b5 d3       	rcall	.+1898   	; 0x968 <__muluhisi3>
 1fe:	23 e0       	ldi	r18, 0x03	; 3
 200:	f6 95       	lsr	r31
 202:	e7 95       	ror	r30
 204:	2a 95       	dec	r18
 206:	e1 f7       	brne	.-8      	; 0x200 <micros+0x3e>
 208:	6e 0f       	add	r22, r30
 20a:	7f 1f       	adc	r23, r31
 20c:	81 1d       	adc	r24, r1
 20e:	91 1d       	adc	r25, r1
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:893
        microseconds = ((overflows * millisClockCyclesToMicroseconds(TIME_TRACKING_CYCLES_PER_OVF))
                      + (ticks * (millisClockCyclesToMicroseconds(TIME_TRACKING_CYCLES_PER_OVF) / TIME_TRACKING_TIMER_PERIOD)));
      #endif
    #endif // end of timer-specific part of micros calculations
    return microseconds;
  }
 210:	08 95       	ret

00000212 <Adafruit_NeoPixel::show() [clone .constprop.9]>:
_ZN17Adafruit_NeoPixel4showEv.constprop.9():
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:419
           function is called (about 30 microseconds per RGB pixel, 40 for
           RGBW pixels). There's no easy fix for this, but a few
           specialized alternative or companion libraries exist that use
           very device-specific peripherals to work around it.
*/
void Adafruit_NeoPixel::show(void) {
 212:	0f 93       	push	r16
 214:	1f 93       	push	r17
 216:	cf 93       	push	r28
 218:	df 93       	push	r29
 21a:	cd b7       	in	r28, 0x3d	; 61
 21c:	de b7       	in	r29, 0x3e	; 62
 21e:	29 97       	sbiw	r28, 0x09	; 9
 220:	cd bf       	out	0x3d, r28	; 61
 222:	de bf       	out	0x3e, r29	; 62
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:421

  if (!pixels)
 224:	80 91 13 34 	lds	r24, 0x3413	; 0x803413 <strip+0x9>
 228:	90 91 14 34 	lds	r25, 0x3414	; 0x803414 <strip+0xa>
 22c:	89 2b       	or	r24, r25
 22e:	09 f4       	brne	.+2      	; 0x232 <Adafruit_NeoPixel::show() [clone .constprop.9]+0x20>
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.h:273
    // show() call happens precisely around the rollover, but that's
    // neither likely nor especially harmful, vs. other code that might
    // stall for 30+ minutes, or having to document and frequently remind
    // and/or provide tech support explaining an unintuitive need for
    // show() calls at least once an hour.
    uint32_t now = micros();
 230:	7a c0       	rjmp	.+244    	; 0x326 <nextbyte20+0x32>
_ZN17Adafruit_NeoPixel7canShowEv.isra.0():
 232:	c7 df       	rcall	.-114    	; 0x1c2 <micros>
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.h:274
    if (endTime > now) {
 234:	00 91 19 34 	lds	r16, 0x3419	; 0x803419 <strip+0xf>
 238:	10 91 1a 34 	lds	r17, 0x341A	; 0x80341a <strip+0x10>
 23c:	20 91 1b 34 	lds	r18, 0x341B	; 0x80341b <strip+0x11>
 240:	30 91 1c 34 	lds	r19, 0x341C	; 0x80341c <strip+0x12>
 244:	60 17       	cp	r22, r16
 246:	71 07       	cpc	r23, r17
 248:	82 07       	cpc	r24, r18
 24a:	93 07       	cpc	r25, r19
 24c:	40 f4       	brcc	.+16     	; 0x25e <Adafruit_NeoPixel::show() [clone .constprop.9]+0x4c>
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.h:275
      endTime = now;
 24e:	60 93 19 34 	sts	0x3419, r22	; 0x803419 <strip+0xf>
 252:	70 93 1a 34 	sts	0x341A, r23	; 0x80341a <strip+0x10>
 256:	80 93 1b 34 	sts	0x341B, r24	; 0x80341b <strip+0x11>
 25a:	90 93 1c 34 	sts	0x341C, r25	; 0x80341c <strip+0x12>
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.h:277
    }
    return (now - endTime) >= 300L;
 25e:	00 91 19 34 	lds	r16, 0x3419	; 0x803419 <strip+0xf>
 262:	10 91 1a 34 	lds	r17, 0x341A	; 0x80341a <strip+0x10>
 266:	20 91 1b 34 	lds	r18, 0x341B	; 0x80341b <strip+0x11>
 26a:	30 91 1c 34 	lds	r19, 0x341C	; 0x80341c <strip+0x12>
 26e:	60 1b       	sub	r22, r16
 270:	71 0b       	sbc	r23, r17
 272:	82 0b       	sbc	r24, r18
 274:	93 0b       	sbc	r25, r19
_ZN17Adafruit_NeoPixel4showEv.constprop.9():
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:430
  // put a delay at the end of the function, the ending time is noted and
  // the function will simply hold off (if needed) on issuing the
  // subsequent round of data until the latch time has elapsed. This
  // allows the mainline code to start generating the next frame of data
  // rather than stalling for the latch.
  while (!canShow())
 276:	6c 32       	cpi	r22, 0x2C	; 44
 278:	71 40       	sbci	r23, 0x01	; 1
 27a:	81 05       	cpc	r24, r1
 27c:	91 05       	cpc	r25, r1
 27e:	c8 f2       	brcs	.-78     	; 0x232 <Adafruit_NeoPixel::show() [clone .constprop.9]+0x20>
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:449
    // to the PORT register as needed.

  // NRF52 may use PWM + DMA (if available), may not need to disable interrupt
  // ESP32 may not disable interrupts because espShow() uses RMT which tries to acquire locks
#if !(defined(NRF52) || defined(NRF52_SERIES) || defined(ESP32))
  noInterrupts(); // Need 100% focus on instruction timing
 280:	f8 94       	cli
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:455
#endif

#if defined(__AVR__)
  // AVR MCUs -- ATmega & ATtiny (no XMEGA) ---------------------------------

  volatile uint16_t i = numBytes; // Loop counter
 282:	80 91 0e 34 	lds	r24, 0x340E	; 0x80340e <strip+0x4>
 286:	90 91 0f 34 	lds	r25, 0x340F	; 0x80340f <strip+0x5>
 28a:	89 83       	std	Y+1, r24	; 0x01
 28c:	9a 83       	std	Y+2, r25	; 0x02
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:456
  volatile uint8_t *ptr = pixels, // Pointer to next byte
 28e:	e0 91 13 34 	lds	r30, 0x3413	; 0x803413 <strip+0x9>
 292:	f0 91 14 34 	lds	r31, 0x3414	; 0x803414 <strip+0xa>
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:457
      b = *ptr++,                 // Current byte value
 296:	df 01       	movw	r26, r30
 298:	11 96       	adiw	r26, 0x01	; 1
 29a:	80 81       	ld	r24, Z
 29c:	89 87       	std	Y+9, r24	; 0x09
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:1677

// 16 MHz(ish) AVR --------------------------------------------------------
#elif (F_CPU >= 15400000UL) && (F_CPU <= 19000000L)

#if defined(NEO_KHZ400) // 800 KHz check needed only if 400 KHz support enabled
  if (is800KHz) {
 29e:	90 91 0a 34 	lds	r25, 0x340A	; 0x80340a <strip>
 2a2:	e0 91 1d 34 	lds	r30, 0x341D	; 0x80341d <strip+0x13>
 2a6:	f0 91 1e 34 	lds	r31, 0x341E	; 0x80341e <strip+0x14>
 2aa:	80 91 1f 34 	lds	r24, 0x341F	; 0x80341f <strip+0x15>
 2ae:	99 23       	and	r25, r25
 2b0:	09 f4       	brne	.+2      	; 0x2b4 <Adafruit_NeoPixel::show() [clone .constprop.9]+0xa2>
 2b2:	41 c0       	rjmp	.+130    	; 0x336 <nextbyte20+0x42>
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:1688
    // 20 inst. clocks per bit: HHHHHxxxxxxxxLLLLLLL
    // ST instructions:         ^   ^        ^       (T=0,5,13)

    volatile uint8_t next, bit;

    hi = *port | pinMask;
 2b4:	90 81       	ld	r25, Z
 2b6:	98 2b       	or	r25, r24
 2b8:	98 87       	std	Y+8, r25	; 0x08
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:1689
    lo = *port & ~pinMask;
 2ba:	90 81       	ld	r25, Z
 2bc:	80 95       	com	r24
 2be:	89 23       	and	r24, r25
 2c0:	8f 83       	std	Y+7, r24	; 0x07
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:1690
    next = lo;
 2c2:	8f 81       	ldd	r24, Y+7	; 0x07
 2c4:	8c 83       	std	Y+4, r24	; 0x04
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:1691
    bit = 8;
 2c6:	88 e0       	ldi	r24, 0x08	; 8
 2c8:	8b 83       	std	Y+3, r24	; 0x03
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:1739
                 "\n\t" // 2    i--           (T = 18)
                 "brne head20"
                 "\n" // 2    if(i != 0) -> (next byte)
                 : [port] "+e"(port), [byte] "+r"(b), [bit] "+r"(bit),
                   [next] "+r"(next), [count] "+w"(i)
                 : [ptr] "e"(ptr), [hi] "r"(hi), [lo] "r"(lo));
 2ca:	58 85       	ldd	r21, Y+8	; 0x08
 2cc:	6f 81       	ldd	r22, Y+7	; 0x07
 2ce:	49 85       	ldd	r20, Y+9	; 0x09
 2d0:	3b 81       	ldd	r19, Y+3	; 0x03
 2d2:	2c 81       	ldd	r18, Y+4	; 0x04
 2d4:	89 81       	ldd	r24, Y+1	; 0x01
 2d6:	9a 81       	ldd	r25, Y+2	; 0x02

000002d8 <head20>:
 2d8:	50 83       	st	Z, r21
 2da:	47 fd       	sbrc	r20, 7
 2dc:	25 2f       	mov	r18, r21
 2de:	3a 95       	dec	r19
 2e0:	20 83       	st	Z, r18
 2e2:	26 2f       	mov	r18, r22
 2e4:	39 f0       	breq	.+14     	; 0x2f4 <nextbyte20>
 2e6:	44 1f       	adc	r20, r20
 2e8:	00 c0       	rjmp	.+0      	; 0x2ea <head20+0x12>
 2ea:	00 00       	nop
 2ec:	60 83       	st	Z, r22
 2ee:	00 00       	nop
 2f0:	00 c0       	rjmp	.+0      	; 0x2f2 <head20+0x1a>
 2f2:	f2 cf       	rjmp	.-28     	; 0x2d8 <head20>

000002f4 <nextbyte20>:
 2f4:	38 e0       	ldi	r19, 0x08	; 8
 2f6:	4d 91       	ld	r20, X+
 2f8:	60 83       	st	Z, r22
 2fa:	00 00       	nop
 2fc:	01 97       	sbiw	r24, 0x01	; 1
 2fe:	61 f7       	brne	.-40     	; 0x2d8 <head20>
 300:	e0 93 1d 34 	sts	0x341D, r30	; 0x80341d <strip+0x13>
 304:	f0 93 1e 34 	sts	0x341E, r31	; 0x80341e <strip+0x14>
 308:	49 87       	std	Y+9, r20	; 0x09
 30a:	3b 83       	std	Y+3, r19	; 0x03
 30c:	2c 83       	std	Y+4, r18	; 0x04
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:1824
                 "\n\t" // 2    i--           (T = 38)
                 "brne head40"
                 "\n" // 1-2  if(i != 0) -> (next byte)
                 : [port] "+e"(port), [byte] "+r"(b), [bit] "+r"(bit),
                   [next] "+r"(next), [count] "+w"(i)
                 : [ptr] "e"(ptr), [hi] "r"(hi), [lo] "r"(lo));
 30e:	89 83       	std	Y+1, r24	; 0x01
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:3281
#endif

  // END ARCHITECTURE SELECT ------------------------------------------------

#if !(defined(NRF52) || defined(NRF52_SERIES) || defined(ESP32))
  interrupts();
 310:	9a 83       	std	Y+2, r25	; 0x02
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:3284
#endif

  endTime = micros(); // Save EOD time for latch on next call
 312:	78 94       	sei
 314:	56 df       	rcall	.-340    	; 0x1c2 <micros>
 316:	60 93 19 34 	sts	0x3419, r22	; 0x803419 <strip+0xf>
 31a:	70 93 1a 34 	sts	0x341A, r23	; 0x80341a <strip+0x10>
 31e:	80 93 1b 34 	sts	0x341B, r24	; 0x80341b <strip+0x11>
 322:	90 93 1c 34 	sts	0x341C, r25	; 0x80341c <strip+0x12>
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:3285
}
 326:	29 96       	adiw	r28, 0x09	; 9
 328:	cd bf       	out	0x3d, r28	; 61
 32a:	de bf       	out	0x3e, r29	; 62
 32c:	df 91       	pop	r29
 32e:	cf 91       	pop	r28
 330:	1f 91       	pop	r17
 332:	0f 91       	pop	r16
 334:	08 95       	ret
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:1751
    // 40 inst. clocks per bit: HHHHHHHHxxxxxxxxxxxxLLLLLLLLLLLLLLLLLLLL
    // ST instructions:         ^       ^           ^         (T=0,8,20)

    volatile uint8_t next, bit;

    hi = *port | pinMask;
 336:	90 81       	ld	r25, Z
 338:	98 2b       	or	r25, r24
 33a:	98 87       	std	Y+8, r25	; 0x08
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:1752
    lo = *port & ~pinMask;
 33c:	90 81       	ld	r25, Z
 33e:	80 95       	com	r24
 340:	89 23       	and	r24, r25
 342:	8f 83       	std	Y+7, r24	; 0x07
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:1753
    next = lo;
 344:	8f 81       	ldd	r24, Y+7	; 0x07
 346:	8e 83       	std	Y+6, r24	; 0x06
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:1754
    bit = 8;
 348:	88 e0       	ldi	r24, 0x08	; 8
 34a:	8d 83       	std	Y+5, r24	; 0x05
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:1824
                 "\n\t" // 2    i--           (T = 38)
                 "brne head40"
                 "\n" // 1-2  if(i != 0) -> (next byte)
                 : [port] "+e"(port), [byte] "+r"(b), [bit] "+r"(bit),
                   [next] "+r"(next), [count] "+w"(i)
                 : [ptr] "e"(ptr), [hi] "r"(hi), [lo] "r"(lo));
 34c:	58 85       	ldd	r21, Y+8	; 0x08
 34e:	6f 81       	ldd	r22, Y+7	; 0x07
 350:	49 85       	ldd	r20, Y+9	; 0x09
 352:	3d 81       	ldd	r19, Y+5	; 0x05
 354:	2e 81       	ldd	r18, Y+6	; 0x06
 356:	89 81       	ldd	r24, Y+1	; 0x01
 358:	9a 81       	ldd	r25, Y+2	; 0x02

0000035a <head40>:
 35a:	50 83       	st	Z, r21
 35c:	47 fd       	sbrc	r20, 7
 35e:	25 2f       	mov	r18, r21
 360:	00 c0       	rjmp	.+0      	; 0x362 <head40+0x8>
 362:	00 c0       	rjmp	.+0      	; 0x364 <head40+0xa>
 364:	20 83       	st	Z, r18
 366:	00 c0       	rjmp	.+0      	; 0x368 <head40+0xe>
 368:	00 c0       	rjmp	.+0      	; 0x36a <head40+0x10>
 36a:	00 c0       	rjmp	.+0      	; 0x36c <head40+0x12>
 36c:	00 c0       	rjmp	.+0      	; 0x36e <head40+0x14>
 36e:	00 c0       	rjmp	.+0      	; 0x370 <head40+0x16>
 370:	60 83       	st	Z, r22
 372:	00 00       	nop
 374:	26 2f       	mov	r18, r22
 376:	3a 95       	dec	r19
 378:	41 f0       	breq	.+16     	; 0x38a <nextbyte40>
 37a:	44 1f       	adc	r20, r20
 37c:	00 00       	nop
 37e:	00 c0       	rjmp	.+0      	; 0x380 <head40+0x26>
 380:	00 c0       	rjmp	.+0      	; 0x382 <head40+0x28>
 382:	00 c0       	rjmp	.+0      	; 0x384 <head40+0x2a>
 384:	00 c0       	rjmp	.+0      	; 0x386 <head40+0x2c>
 386:	00 c0       	rjmp	.+0      	; 0x388 <head40+0x2e>
 388:	e8 cf       	rjmp	.-48     	; 0x35a <head40>

0000038a <nextbyte40>:
 38a:	38 e0       	ldi	r19, 0x08	; 8
 38c:	4d 91       	ld	r20, X+
 38e:	00 c0       	rjmp	.+0      	; 0x390 <nextbyte40+0x6>
 390:	60 83       	st	Z, r22
 392:	00 c0       	rjmp	.+0      	; 0x394 <nextbyte40+0xa>
 394:	01 97       	sbiw	r24, 0x01	; 1
 396:	09 f7       	brne	.-62     	; 0x35a <head40>
 398:	e0 93 1d 34 	sts	0x341D, r30	; 0x80341d <strip+0x13>
 39c:	f0 93 1e 34 	sts	0x341E, r31	; 0x80341e <strip+0x14>
 3a0:	49 87       	std	Y+9, r20	; 0x09
 3a2:	3d 83       	std	Y+5, r19	; 0x05
 3a4:	2e 83       	std	Y+6, r18	; 0x06
 3a6:	b3 cf       	rjmp	.-154    	; 0x30e <nextbyte20+0x1a>

000003a8 <delay>:
delay():
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:961
        _delay_ms(1);
      }
    }
  }
#elif (PROGMEM_SIZE >= 16384 && !defined(MILLIS_USE_TIMERRTC))
  void delay(uint32_t ms) { /* Interrupts will not prolong this less flash-efficient delay */
 3a8:	cf 92       	push	r12
 3aa:	df 92       	push	r13
 3ac:	ef 92       	push	r14
 3ae:	ff 92       	push	r15
 3b0:	cf 93       	push	r28
 3b2:	df 93       	push	r29
 3b4:	6b 01       	movw	r12, r22
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:962
    uint16_t start = (uint16_t) micros();
 3b6:	7c 01       	movw	r14, r24
 3b8:	04 df       	rcall	.-504    	; 0x1c2 <micros>
 3ba:	eb 01       	movw	r28, r22
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:963
    while (ms > 0) {
 3bc:	c1 14       	cp	r12, r1
 3be:	d1 04       	cpc	r13, r1
 3c0:	e1 04       	cpc	r14, r1
 3c2:	f1 04       	cpc	r15, r1
 3c4:	41 f4       	brne	.+16     	; 0x3d6 <delay+0x2e>
 3c6:	12 c0       	rjmp	.+36     	; 0x3ec <delay+0x44>
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:965
      while (((uint16_t) micros() - start) >= 1000 && ms) {
        ms-- ;
 3c8:	81 e0       	ldi	r24, 0x01	; 1
 3ca:	c8 1a       	sub	r12, r24
 3cc:	d1 08       	sbc	r13, r1
 3ce:	e1 08       	sbc	r14, r1
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:966
        start += 1000;
 3d0:	f1 08       	sbc	r15, r1
 3d2:	c8 51       	subi	r28, 0x18	; 24
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:964
  }
#elif (PROGMEM_SIZE >= 16384 && !defined(MILLIS_USE_TIMERRTC))
  void delay(uint32_t ms) { /* Interrupts will not prolong this less flash-efficient delay */
    uint16_t start = (uint16_t) micros();
    while (ms > 0) {
      while (((uint16_t) micros() - start) >= 1000 && ms) {
 3d4:	dc 4f       	sbci	r29, 0xFC	; 252
 3d6:	f5 de       	rcall	.-534    	; 0x1c2 <micros>
 3d8:	6c 1b       	sub	r22, r28
 3da:	7d 0b       	sbc	r23, r29
 3dc:	68 3e       	cpi	r22, 0xE8	; 232
 3de:	73 40       	sbci	r23, 0x03	; 3
 3e0:	68 f3       	brcs	.-38     	; 0x3bc <delay+0x14>
 3e2:	c1 14       	cp	r12, r1
 3e4:	d1 04       	cpc	r13, r1
 3e6:	e1 04       	cpc	r14, r1
 3e8:	f1 04       	cpc	r15, r1
 3ea:	71 f7       	brne	.-36     	; 0x3c8 <delay+0x20>
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:969
        ms-- ;
        start += 1000;
      }
    }
  }
 3ec:	df 91       	pop	r29
 3ee:	cf 91       	pop	r28
 3f0:	ff 90       	pop	r15
 3f2:	ef 90       	pop	r14
 3f4:	df 90       	pop	r13
 3f6:	cf 90       	pop	r12
 3f8:	08 95       	ret

000003fa <colorWipe(unsigned long, unsigned char) [clone .constprop.4]>:
_Z9colorWipemh.constprop.4():
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:52
  rainbowCycle(20);
  theaterChaseRainbow(50);
}

// Fill the dots one after the other with a color
void colorWipe(uint32_t c, uint8_t wait) {
 3fa:	cf 92       	push	r12
 3fc:	df 92       	push	r13
 3fe:	ef 92       	push	r14
 400:	ff 92       	push	r15
 402:	cf 93       	push	r28
 404:	df 93       	push	r29
 406:	6b 01       	movw	r12, r22
 408:	7c 01       	movw	r14, r24
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:53
  for(uint16_t i=0; i<strip.numPixels(); i++) {
 40a:	d0 e0       	ldi	r29, 0x00	; 0
 40c:	c0 e0       	ldi	r28, 0x00	; 0
 40e:	80 91 0c 34 	lds	r24, 0x340C	; 0x80340c <strip+0x2>
 412:	90 91 0d 34 	lds	r25, 0x340D	; 0x80340d <strip+0x3>
 416:	c8 17       	cp	r28, r24
 418:	d9 07       	cpc	r29, r25
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:54
    strip.setPixelColor(i, c);
 41a:	60 f4       	brcc	.+24     	; 0x434 <__LOCK_REGION_LENGTH__+0x34>
 41c:	b7 01       	movw	r22, r14
 41e:	a6 01       	movw	r20, r12
 420:	ce 01       	movw	r24, r28
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:55
    strip.show();
 422:	5e de       	rcall	.-836    	; 0xe0 <Adafruit_NeoPixel::setPixelColor(unsigned int, unsigned long) [clone .constprop.5]>
 424:	f6 de       	rcall	.-532    	; 0x212 <Adafruit_NeoPixel::show() [clone .constprop.9]>
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:56
    delay(wait);
 426:	62 e3       	ldi	r22, 0x32	; 50
 428:	70 e0       	ldi	r23, 0x00	; 0
 42a:	80 e0       	ldi	r24, 0x00	; 0
 42c:	90 e0       	ldi	r25, 0x00	; 0
 42e:	bc df       	rcall	.-136    	; 0x3a8 <delay>
 430:	21 96       	adiw	r28, 0x01	; 1
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:53
  theaterChaseRainbow(50);
}

// Fill the dots one after the other with a color
void colorWipe(uint32_t c, uint8_t wait) {
  for(uint16_t i=0; i<strip.numPixels(); i++) {
 432:	ed cf       	rjmp	.-38     	; 0x40e <__LOCK_REGION_LENGTH__+0xe>
 434:	df 91       	pop	r29
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:58
    strip.setPixelColor(i, c);
    strip.show();
    delay(wait);
  }
}
 436:	cf 91       	pop	r28
 438:	ff 90       	pop	r15
 43a:	ef 90       	pop	r14
 43c:	df 90       	pop	r13
 43e:	cf 90       	pop	r12
 440:	08 95       	ret

00000442 <theaterChase(unsigned long, unsigned char) [clone .constprop.3]>:
_Z12theaterChasemh.constprop.3():
 442:	8f 92       	push	r8
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:86
    delay(wait);
  }
}

//Theatre-style crawling lights.
void theaterChase(uint32_t c, uint8_t wait) {
 444:	9f 92       	push	r9
 446:	af 92       	push	r10
 448:	bf 92       	push	r11
 44a:	ef 92       	push	r14
 44c:	ff 92       	push	r15
 44e:	0f 93       	push	r16
 450:	1f 93       	push	r17
 452:	cf 93       	push	r28
 454:	df 93       	push	r29
 456:	4b 01       	movw	r8, r22
 458:	5c 01       	movw	r10, r24
 45a:	8a e0       	ldi	r24, 0x0A	; 10
 45c:	e8 2e       	mov	r14, r24
 45e:	f1 2c       	mov	r15, r1
 460:	d0 e0       	ldi	r29, 0x00	; 0
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:88
  for (int j=0; j<10; j++) {  //do 10 cycles of chasing
    for (int q=0; q < 3; q++) {
 462:	c0 e0       	ldi	r28, 0x00	; 0
 464:	10 e0       	ldi	r17, 0x00	; 0
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:89
      for (uint16_t i=0; i < strip.numPixels(); i=i+3) {
 466:	00 e0       	ldi	r16, 0x00	; 0
 468:	80 91 0c 34 	lds	r24, 0x340C	; 0x80340c <strip+0x2>
 46c:	90 91 0d 34 	lds	r25, 0x340D	; 0x80340d <strip+0x3>
 470:	08 17       	cp	r16, r24
 472:	19 07       	cpc	r17, r25
 474:	48 f4       	brcc	.+18     	; 0x488 <theaterChase(unsigned long, unsigned char) [clone .constprop.3]+0x46>
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:90
        strip.setPixelColor(i+q, c);    //turn every third pixel on
 476:	b5 01       	movw	r22, r10
 478:	a4 01       	movw	r20, r8
 47a:	ce 01       	movw	r24, r28
 47c:	80 0f       	add	r24, r16
 47e:	91 1f       	adc	r25, r17
 480:	2f de       	rcall	.-930    	; 0xe0 <Adafruit_NeoPixel::setPixelColor(unsigned int, unsigned long) [clone .constprop.5]>
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:89

//Theatre-style crawling lights.
void theaterChase(uint32_t c, uint8_t wait) {
  for (int j=0; j<10; j++) {  //do 10 cycles of chasing
    for (int q=0; q < 3; q++) {
      for (uint16_t i=0; i < strip.numPixels(); i=i+3) {
 482:	0d 5f       	subi	r16, 0xFD	; 253
 484:	1f 4f       	sbci	r17, 0xFF	; 255
 486:	f0 cf       	rjmp	.-32     	; 0x468 <theaterChase(unsigned long, unsigned char) [clone .constprop.3]+0x26>
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:92
        strip.setPixelColor(i+q, c);    //turn every third pixel on
      }
      strip.show();
 488:	c4 de       	rcall	.-632    	; 0x212 <Adafruit_NeoPixel::show() [clone .constprop.9]>
 48a:	62 e3       	ldi	r22, 0x32	; 50
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:94

      delay(wait);
 48c:	70 e0       	ldi	r23, 0x00	; 0
 48e:	80 e0       	ldi	r24, 0x00	; 0
 490:	90 e0       	ldi	r25, 0x00	; 0
 492:	8a df       	rcall	.-236    	; 0x3a8 <delay>
 494:	10 e0       	ldi	r17, 0x00	; 0
 496:	00 e0       	ldi	r16, 0x00	; 0
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:96

      for (uint16_t i=0; i < strip.numPixels(); i=i+3) {
 498:	80 91 0c 34 	lds	r24, 0x340C	; 0x80340c <strip+0x2>
 49c:	90 91 0d 34 	lds	r25, 0x340D	; 0x80340d <strip+0x3>
 4a0:	08 17       	cp	r16, r24
 4a2:	19 07       	cpc	r17, r25
 4a4:	50 f4       	brcc	.+20     	; 0x4ba <theaterChase(unsigned long, unsigned char) [clone .constprop.3]+0x78>
 4a6:	40 e0       	ldi	r20, 0x00	; 0
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:97
        strip.setPixelColor(i+q, 0);        //turn every third pixel off
 4a8:	50 e0       	ldi	r21, 0x00	; 0
 4aa:	ba 01       	movw	r22, r20
 4ac:	ce 01       	movw	r24, r28
 4ae:	80 0f       	add	r24, r16
 4b0:	91 1f       	adc	r25, r17
 4b2:	16 de       	rcall	.-980    	; 0xe0 <Adafruit_NeoPixel::setPixelColor(unsigned int, unsigned long) [clone .constprop.5]>
 4b4:	0d 5f       	subi	r16, 0xFD	; 253
 4b6:	1f 4f       	sbci	r17, 0xFF	; 255
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:96
      }
      strip.show();

      delay(wait);

      for (uint16_t i=0; i < strip.numPixels(); i=i+3) {
 4b8:	ef cf       	rjmp	.-34     	; 0x498 <theaterChase(unsigned long, unsigned char) [clone .constprop.3]+0x56>
 4ba:	21 96       	adiw	r28, 0x01	; 1
 4bc:	c3 30       	cpi	r28, 0x03	; 3
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:88
}

//Theatre-style crawling lights.
void theaterChase(uint32_t c, uint8_t wait) {
  for (int j=0; j<10; j++) {  //do 10 cycles of chasing
    for (int q=0; q < 3; q++) {
 4be:	d1 05       	cpc	r29, r1
 4c0:	89 f6       	brne	.-94     	; 0x464 <theaterChase(unsigned long, unsigned char) [clone .constprop.3]+0x22>
 4c2:	81 e0       	ldi	r24, 0x01	; 1
 4c4:	e8 1a       	sub	r14, r24
 4c6:	f1 08       	sbc	r15, r1
 4c8:	59 f6       	brne	.-106    	; 0x460 <theaterChase(unsigned long, unsigned char) [clone .constprop.3]+0x1e>
 4ca:	df 91       	pop	r29
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:87
  }
}

//Theatre-style crawling lights.
void theaterChase(uint32_t c, uint8_t wait) {
  for (int j=0; j<10; j++) {  //do 10 cycles of chasing
 4cc:	cf 91       	pop	r28
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:101
      for (uint16_t i=0; i < strip.numPixels(); i=i+3) {
        strip.setPixelColor(i+q, 0);        //turn every third pixel off
      }
    }
  }
}
 4ce:	1f 91       	pop	r17
 4d0:	0f 91       	pop	r16
 4d2:	ff 90       	pop	r15
 4d4:	ef 90       	pop	r14
 4d6:	bf 90       	pop	r11
 4d8:	af 90       	pop	r10
 4da:	9f 90       	pop	r9
 4dc:	8f 90       	pop	r8
 4de:	08 95       	ret

000004e0 <Wheel(unsigned char)>:
_Z5Wheelh():
 4e0:	28 2f       	mov	r18, r24
 4e2:	20 95       	com	r18
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:124
}

// Input a value 0 to 255 to get a color value.
// The colours are a transition r - g - b - back to r.
uint32_t Wheel(byte WheelPos) {
  WheelPos = 255 - WheelPos;
 4e4:	25 35       	cpi	r18, 0x55	; 85
 4e6:	98 f4       	brcc	.+38     	; 0x50e <Wheel(unsigned char)+0x2e>
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:125
  if(WheelPos < 85) {
 4e8:	82 2f       	mov	r24, r18
 4ea:	88 0f       	add	r24, r24
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:126
    return strip.Color(255 - WheelPos * 3, 0, WheelPos * 3);
 4ec:	88 0f       	add	r24, r24
 4ee:	62 2f       	mov	r22, r18
 4f0:	68 1b       	sub	r22, r24
 4f2:	9f ef       	ldi	r25, 0xFF	; 255
 4f4:	96 0f       	add	r25, r22
_ZN17Adafruit_NeoPixel5ColorEhhh():
 4f6:	69 2f       	mov	r22, r25
 4f8:	70 e0       	ldi	r23, 0x00	; 0
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.h:347
             variable for later use or passed to the setPixelColor()
             function. Packed RGB format is predictable, regardless of
             LED strand color order.
  */
  static uint32_t Color(uint8_t r, uint8_t g, uint8_t b) {
    return ((uint32_t)r << 16) | ((uint32_t)g << 8) | b;
 4fa:	90 e0       	ldi	r25, 0x00	; 0
 4fc:	80 e0       	ldi	r24, 0x00	; 0
 4fe:	cb 01       	movw	r24, r22
 500:	77 27       	eor	r23, r23
 502:	66 27       	eor	r22, r22
_Z5Wheelh():
 504:	32 2f       	mov	r19, r18
 506:	33 0f       	add	r19, r19
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:126
 508:	23 0f       	add	r18, r19
_ZN17Adafruit_NeoPixel5ColorEhhh():
 50a:	62 2b       	or	r22, r18
 50c:	08 95       	ret
_Z5Wheelh():
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.h:347
 50e:	2a 3a       	cpi	r18, 0xAA	; 170
 510:	88 f4       	brcc	.+34     	; 0x534 <Wheel(unsigned char)+0x54>
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:128
  }
  if(WheelPos < 170) {
 512:	25 55       	subi	r18, 0x55	; 85
 514:	62 2f       	mov	r22, r18
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:129
    WheelPos -= 85;
 516:	66 0f       	add	r22, r22
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:130
    return strip.Color(0, WheelPos * 3, 255 - WheelPos * 3);
 518:	62 0f       	add	r22, r18
_ZN17Adafruit_NeoPixel5ColorEhhh():
 51a:	70 e0       	ldi	r23, 0x00	; 0
 51c:	90 e0       	ldi	r25, 0x00	; 0
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.h:347
 51e:	80 e0       	ldi	r24, 0x00	; 0
 520:	98 2f       	mov	r25, r24
 522:	87 2f       	mov	r24, r23
 524:	76 2f       	mov	r23, r22
 526:	66 27       	eor	r22, r22
_Z5Wheelh():
 528:	32 2f       	mov	r19, r18
 52a:	33 0f       	add	r19, r19
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:130
 52c:	33 0f       	add	r19, r19
 52e:	23 1b       	sub	r18, r19
 530:	21 50       	subi	r18, 0x01	; 1
 532:	eb cf       	rjmp	.-42     	; 0x50a <Wheel(unsigned char)+0x2a>
 534:	2a 5a       	subi	r18, 0xAA	; 170
 536:	82 2f       	mov	r24, r18
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:132
  }
  WheelPos -= 170;
 538:	88 0f       	add	r24, r24
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:133
  return strip.Color(WheelPos * 3, 255 - WheelPos * 3, 0);
 53a:	88 0f       	add	r24, r24
 53c:	32 2f       	mov	r19, r18
 53e:	38 1b       	sub	r19, r24
 540:	31 50       	subi	r19, 0x01	; 1
 542:	62 2f       	mov	r22, r18
 544:	66 0f       	add	r22, r22
 546:	62 0f       	add	r22, r18
_ZN17Adafruit_NeoPixel5ColorEhhh():
 548:	70 e0       	ldi	r23, 0x00	; 0
 54a:	90 e0       	ldi	r25, 0x00	; 0
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.h:347
 54c:	80 e0       	ldi	r24, 0x00	; 0
 54e:	cb 01       	movw	r24, r22
 550:	77 27       	eor	r23, r23
 552:	66 27       	eor	r22, r22
 554:	73 2b       	or	r23, r19
_Z5Wheelh():
 556:	08 95       	ret

00000558 <digitalWrite.constprop.17>:
digitalWrite.constprop.17():
 558:	cf 93       	push	r28
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:134
}
 55a:	df 93       	push	r29
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:240
    default:
      break;
  }
}

void digitalWrite(uint8_t pin, uint8_t val) {
 55c:	8c 30       	cpi	r24, 0x0C	; 12
 55e:	08 f0       	brcs	.+2      	; 0x562 <digitalWrite.constprop.17+0xa>
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:243
  check_valid_digital_pin(pin);
  /* Get bit mask for pin */
  uint8_t bit_mask = digitalPinToBitMask(pin);
 560:	3e c0       	rjmp	.+124    	; 0x5de <digitalWrite.constprop.17+0x86>
check_valid_digital_pin():
 562:	90 e0       	ldi	r25, 0x00	; 0
digitalWrite.constprop.17():
 564:	ec 01       	movw	r28, r24
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/Arduino.h:873
#if !defined(NUM_TOTAL_PINS)
  #define NUM_TOTAL_PINS                (NUM_DIGITAL_PINS) /* Used the same way as NUM_DIGITAL_PINS. so it doesn't mean what it's named  - I didn't make the convention*/
#endif

inline __attribute__((always_inline)) void check_valid_digital_pin(pin_size_t pin) {
  if (__builtin_constant_p(pin)) {
 566:	c4 5d       	subi	r28, 0xD4	; 212
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:243
 568:	d3 47       	sbci	r29, 0x73	; 115
 56a:	28 81       	ld	r18, Y
 56c:	2f 3f       	cpi	r18, 0xFF	; 255
 56e:	b9 f1       	breq	.+110    	; 0x5de <digitalWrite.constprop.17+0x86>
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:244
  if (bit_mask == NOT_A_PIN) {
 570:	ac 01       	movw	r20, r24
 572:	40 5e       	subi	r20, 0xE0	; 224
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:249
    return;
  }

  /* Get port */
  PORT_t *port = digitalPinToPortStruct(pin);
 574:	53 47       	sbci	r21, 0x73	; 115
 576:	da 01       	movw	r26, r20
 578:	ec 91       	ld	r30, X
 57a:	b0 e2       	ldi	r27, 0x20	; 32
 57c:	eb 9f       	mul	r30, r27
 57e:	f0 01       	movw	r30, r0
 580:	11 24       	eor	r1, r1
 582:	fc 5f       	subi	r31, 0xFC	; 252
 584:	26 83       	std	Z+6, r18	; 0x06
 586:	30 81       	ld	r19, Z
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:258
  you could digitalWrite() a pin while it's an input, to ensure
  that the value of the port was set correctly when it was
  changed to an output. Code in the wild relies on this behavior. */

  if (val == LOW) { /* If LOW */
    port->OUTCLR = bit_mask;
 588:	23 23       	and	r18, r19
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:282
  } else {
    port->OUTSET = bit_mask;
  }

  /* Input direction */
  if (!(port->DIR & bit_mask)) {
 58a:	91 f4       	brne	.+36     	; 0x5b0 <digitalWrite.constprop.17+0x58>
 58c:	9c 01       	movw	r18, r24
 58e:	2c 5e       	subi	r18, 0xEC	; 236
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:289
      pull up is enabled if this function is called.
      Should we purposely implement this side effect?
    */

    /* Get bit position for getting pin ctrl reg */
    uint8_t bit_pos = digitalPinToBitPosition(pin);
 590:	33 47       	sbci	r19, 0x73	; 115
 592:	d9 01       	movw	r26, r18
 594:	2c 91       	ld	r18, X
 596:	30 97       	sbiw	r30, 0x00	; 0
 598:	29 f1       	breq	.+74     	; 0x5e4 <digitalWrite.constprop.17+0x8c>
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:292

    /* Calculate where pin control register is */
    volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);
 59a:	28 30       	cpi	r18, 0x08	; 8
 59c:	18 f5       	brcc	.+70     	; 0x5e4 <digitalWrite.constprop.17+0x8c>
 59e:	70 96       	adiw	r30, 0x10	; 16
 5a0:	e2 0f       	add	r30, r18
 5a2:	f1 1d       	adc	r31, r1
 5a4:	3f b7       	in	r19, 0x3f	; 63
 5a6:	f8 94       	cli
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:295

    /* Save system status and disable interrupts */
    uint8_t status = SREG;
 5a8:	20 81       	ld	r18, Z
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:296
    cli();
 5aa:	27 7f       	andi	r18, 0xF7	; 247
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:300

    if (val == LOW) {
      /* Disable pullup */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
 5ac:	20 83       	st	Z, r18
 5ae:	3f bf       	out	0x3f, r19	; 63
turnOffPWM():
 5b0:	88 5f       	subi	r24, 0xF8	; 248
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:307
      /* Enable pull-up */
      *pin_ctrl_reg |= PORT_PULLUPEN_bm;
    }

    /* Restore system status */
    SREG = status;
 5b2:	93 47       	sbci	r25, 0x73	; 115
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:107
   * any timers with minimum overhead - critical on these parts
   * Since nothing that will show up here can have more than one
   * one bit set, binary and will give 0x00 if that bit is cleared
   * which is NOT_ON_TIMER.
   */
  uint8_t digital_pin_timer =  digitalPinToTimer(pin) & __PeripheralControl;
 5b4:	fc 01       	movw	r30, r24
 5b6:	80 81       	ld	r24, Z
 5b8:	88 23       	and	r24, r24
 5ba:	89 f0       	breq	.+34     	; 0x5de <digitalWrite.constprop.17+0x86>
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:109
  /* end megaTinyCore-specific section */
  if (digital_pin_timer== NOT_ON_TIMER) {
 5bc:	80 31       	cpi	r24, 0x10	; 16
 5be:	79 f4       	brne	.+30     	; 0x5de <digitalWrite.constprop.17+0x86>
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:116
  }

  uint8_t bit_mask = digitalPinToBitMask(pin);
  // TCB_t *timerB;

  switch (digital_pin_timer) {
 5c0:	88 81       	ld	r24, Y
 5c2:	da 01       	movw	r26, r20
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:113
  /* end megaTinyCore-specific section */
  if (digital_pin_timer== NOT_ON_TIMER) {
    return;
  }

  uint8_t bit_mask = digitalPinToBitMask(pin);
 5c4:	9c 91       	ld	r25, X
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:132
          }
          if (bit_mask > 0x04) {  // -> bit_pos > 2 -> output channel controlled by HCMP
            bit_mask <<= 1;       // mind the gap (between LCMP and HCMP)
          }
        #else
          if (digitalPinToPort(pin) == PB) {        // WO0-WO2, Bitmask has one of these bits 1: 0b00hhhlll.
 5c6:	91 30       	cpi	r25, 0x01	; 1
 5c8:	81 f4       	brne	.+32     	; 0x5ea <digitalWrite.constprop.17+0x92>
 5ca:	85 30       	cpi	r24, 0x05	; 5
 5cc:	10 f0       	brcs	.+4      	; 0x5d2 <digitalWrite.constprop.17+0x7a>
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:133
            if (bit_mask > 0x04) { // Is it one of the three high ones? If so
 5ce:	88 0f       	add	r24, r24
 5d0:	82 95       	swap	r24
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:134
              bit_mask <<= 1;      // nudge it 1 place left swap nybbles since that's 1 clock faster than 3 rightshifts.
 5d2:	90 91 01 0a 	lds	r25, 0x0A01	; 0x800a01 <digital_pin_to_bit_mask+0x7f7dd5>
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:142
          } else {
            // Otherwise, it's WO3-5. These will always be on 0b00hhh000,. Here since we ARE working with a high half timer, we need to just leftshift it once.
            bit_mask <<= 1;
          }
        #endif
        TCA0.SPLIT.CTRLB &= ~bit_mask;
 5d6:	80 95       	com	r24
 5d8:	89 23       	and	r24, r25
 5da:	80 93 01 0a 	sts	0x0A01, r24	; 0x800a01 <digital_pin_to_bit_mask+0x7f7dd5>
digitalWrite.constprop.17():
 5de:	df 91       	pop	r29
 5e0:	cf 91       	pop	r28
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:320
   * analogWritten() 255, then digitallyWritten() to HIGH, which
   * would turn it off for the time between turnOffPWM() and
   * PORT->OUTCLR)
   * Since there's no penalty, why make a glitch we don't have to? */
  turnOffPWM(pin);
}
 5e2:	08 95       	ret
 5e4:	f0 e0       	ldi	r31, 0x00	; 0
 5e6:	e0 e0       	ldi	r30, 0x00	; 0
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:292

    /* Get bit position for getting pin ctrl reg */
    uint8_t bit_pos = digitalPinToBitPosition(pin);

    /* Calculate where pin control register is */
    volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);
 5e8:	dd cf       	rjmp	.-70     	; 0x5a4 <digitalWrite.constprop.17+0x4c>
turnOffPWM():
 5ea:	88 0f       	add	r24, r24
 5ec:	f2 cf       	rjmp	.-28     	; 0x5d2 <digitalWrite.constprop.17+0x7a>

000005ee <pinMode>:
pinMode():
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:139
              bit_mask <<= 1;      // nudge it 1 place left swap nybbles since that's 1 clock faster than 3 rightshifts.
              _SWAP(bit_mask);     // swap nybbles since that's 1 clock faster than 3 rightshifts.
            }
          } else {
            // Otherwise, it's WO3-5. These will always be on 0b00hhh000,. Here since we ARE working with a high half timer, we need to just leftshift it once.
            bit_mask <<= 1;
 5ee:	8c 30       	cpi	r24, 0x0C	; 12
 5f0:	e0 f4       	brcc	.+56     	; 0x62a <pinMode+0x3c>
check_valid_digital_pin():
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:44
}

void pinMode(uint8_t pin, uint8_t mode) {
  check_valid_digital_pin(pin);         /* generate compile error if a constant that is not a valid pin is used as the pin */
  check_valid_pin_mode(mode);           /* generate compile error if a constant that is not a valid pin mode is used as the mode */
  uint8_t bit_mask = digitalPinToBitMask(pin);
 5f2:	90 e0       	ldi	r25, 0x00	; 0
pinMode():
 5f4:	fc 01       	movw	r30, r24
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/Arduino.h:873
 5f6:	e4 5d       	subi	r30, 0xD4	; 212
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:44
 5f8:	f3 47       	sbci	r31, 0x73	; 115
 5fa:	20 81       	ld	r18, Z
 5fc:	2f 3f       	cpi	r18, 0xFF	; 255
 5fe:	a9 f0       	breq	.+42     	; 0x62a <pinMode+0x3c>
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:45
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
 600:	fc 01       	movw	r30, r24
 602:	e0 5e       	subi	r30, 0xE0	; 224
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:48
    return;                             /* ignore invalid pins passed at runtime */
  }
  volatile uint8_t * port_base = (volatile uint8_t *) (uint16_t) ((&PORTA) + digitalPinToPort(pin));
 604:	f3 47       	sbci	r31, 0x73	; 115
 606:	e0 81       	ld	r30, Z
 608:	30 e2       	ldi	r19, 0x20	; 32
 60a:	e3 9f       	mul	r30, r19
 60c:	f0 01       	movw	r30, r0
 60e:	11 24       	eor	r1, r1
 610:	fc 5f       	subi	r31, 0xFC	; 252
 612:	66 23       	and	r22, r22
 614:	59 f0       	breq	.+22     	; 0x62c <pinMode+0x3e>
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:49
  if (mode & 0x01) {
 616:	21 83       	std	Z+1, r18	; 0x01
 618:	8c 5e       	subi	r24, 0xEC	; 236
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:51
    // OUTPUT mode, so write DIRSET with the mask.
    *(port_base + 1) = bit_mask;
 61a:	93 47       	sbci	r25, 0x73	; 115
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:77
  // then load with displacement 2 clocks. IFF the compiler puts this pointer into Y or Z, it is faster and smaller
  // by 2 bytes and one clock. And let's hope it is, because the code above would suck too if it was in X.
  // Handwritten assembly that exploited the knowledge that there will never be a carry would save 1 word and 1 clock.
  // and could probably save at least several times that in initializing the port_base pointer. But if you're using
  // pinMode you probably don't care.
  port_base += (uint8_t) digitalPinToBitPosition(pin);
 61c:	dc 01       	movw	r26, r24
 61e:	8c 91       	ld	r24, X
 620:	e8 0f       	add	r30, r24
 622:	f1 1d       	adc	r31, r1
 624:	80 89       	ldd	r24, Z+16	; 0x10
 626:	87 7f       	andi	r24, 0xF7	; 247
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:78
  bit_mask = *(port_base + 0x10);
 628:	80 8b       	std	Z+16, r24	; 0x10
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:82
  if (mode & 2) {
    bit_mask |= 0x08;
  } else {
    bit_mask &= 0xF7;
 62a:	08 95       	ret
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:84
  }
  *(port_base + 0x10) = bit_mask;
 62c:	22 83       	std	Z+2, r18	; 0x02
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:85
}
 62e:	f4 cf       	rjmp	.-24     	; 0x618 <pinMode+0x2a>

00000630 <__vector_25>:
__vector_25():
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring_digital.c:53
  volatile uint8_t * port_base = (volatile uint8_t *) (uint16_t) ((&PORTA) + digitalPinToPort(pin));
  if (mode & 0x01) {
    // OUTPUT mode, so write DIRSET with the mask.
    *(port_base + 1) = bit_mask;
  } else { // otherwise it's input so we write DIRCLR
    *(port_base + 2) = bit_mask;
 630:	8f 93       	push	r24
 632:	81 e0       	ldi	r24, 0x01	; 1
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:206
  #else
    ISR(MILLIS_TIMER_VECTOR, ISR_NAKED) {
      // Common Interrupt header for TCB, TCA and TCD;
      // Clears the Timer Interrupt flag and pushes the CPU Registers
      // 7 words / 7 clocks
      __asm__ __volatile__(
 634:	80 93 96 0a 	sts	0x0A96, r24	; 0x800a96 <digital_pin_to_bit_mask+0x7f7e6a>
 638:	8f b7       	in	r24, 0x3f	; 63
 63a:	8f 93       	push	r24
 63c:	ef 93       	push	r30
 63e:	ff 93       	push	r31
 640:	e6 e0       	ldi	r30, 0x06	; 6
 642:	f4 e3       	ldi	r31, 0x34	; 52
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:218
      "push       r31"            "\n\t" //
      ::  [CLRFL] "M" (_timerS.intClear),
          [PTCLR] "m" (*_timerS.intStatusReg));

    #if (defined(MILLIS_USE_TIMERB0) || defined(MILLIS_USE_TIMERB1) || defined(MILLIS_USE_TIMERB2) || defined(MILLIS_USE_TIMERB3) || defined(MILLIS_USE_TIMERB4))
      __asm__ __volatile__(
 644:	80 81       	ld	r24, Z
 646:	8f 5f       	subi	r24, 0xFF	; 255
 648:	80 83       	st	Z, r24
 64a:	81 81       	ldd	r24, Z+1	; 0x01
 64c:	8f 4f       	sbci	r24, 0xFF	; 255
 64e:	81 83       	std	Z+1, r24	; 0x01
 650:	82 81       	ldd	r24, Z+2	; 0x02
 652:	8f 4f       	sbci	r24, 0xFF	; 255
 654:	82 83       	std	Z+2, r24	; 0x02
 656:	83 81       	ldd	r24, Z+3	; 0x03
 658:	8f 4f       	sbci	r24, 0xFF	; 255
 65a:	83 83       	std	Z+3, r24	; 0x03
 65c:	ff 91       	pop	r31
 65e:	ef 91       	pop	r30
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:379
        [MINCD]  "M" ((0xFFFF - MILLIS_INC) & 0xFF)
      );
    #endif /* (defined(MILLIS_USE_TIMERB0) || defined(MILLIS_USE_TIMERB1) || defined(MILLIS_USE_TIMERB2) || defined(MILLIS_USE_TIMERB3) || defined(MILLIS_USE_TIMERB4)) */
    // Common ISR Epilogue for TCA, TCB and TCD, popping register in reverse Order
    // 6 words, 14 clocks
    __asm__ __volatile__(
 660:	8f 91       	pop	r24
 662:	8f bf       	out	0x3f, r24	; 63
 664:	8f 91       	pop	r24
 666:	18 95       	reti

00000668 <main>:
main():
 668:	88 ed       	ldi	r24, 0xD8	; 216
 66a:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:1539
      #if (F_CPU == 20000000)
        /* No division on clock */
        _PROTECTED_WRITE(CLKCTRL_MCLKCTRLB, 0x00);
      #elif (F_CPU == 16000000)
        /* No division on clock */
        _PROTECTED_WRITE(CLKCTRL_MCLKCTRLB, 0x00);
 66c:	84 bf       	out	0x34, r24	; 52
 66e:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <digital_pin_to_bit_mask+0x7f7435>
init_ADC0():
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:1651


/********************************* ADC ****************************************/
void __attribute__((weak)) init_ADC0() {
  ADC_t* pADC;
  _fastPtr_d(pADC, &ADC0);
 672:	e0 e0       	ldi	r30, 0x00	; 0
 674:	f6 e0       	ldi	r31, 0x06	; 6
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:1702
    #elif F_CPU  >= 24000000            // 25 MHz /10 = 2.50 MHz
      pADC->CTRLB  = ADC_PRESC_DIV10_gc; // 24 MHz /10 = 2.40 MHz
    #elif F_CPU  >= 20000000
      pADC->CTRLB  = ADC_PRESC_DIV8_gc;  // 20 MHz / 8 = 2.50 MHz
    #elif F_CPU  >= 16000000
      pADC->CTRLB  = ADC_PRESC_DIV6_gc;  // 16 MHz / 6 = 2.67 MHz
 676:	82 e0       	ldi	r24, 0x02	; 2
 678:	81 83       	std	Z+1, r24	; 0x01
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:1710
    #elif F_CPU  >=  6000000            // 10 MHz / 4 = 2.50 MHz
      pADC->CTRLB  = ADC_PRESC_DIV4_gc;  //  8 MHz / 4 = 2.00 MHz
    #else                               //  5 MHz / 2 = 2.50 MHz
      pADC->CTRLB  = ADC_PRESC_DIV2_gc;  //  4 MHz / 2 = 2.00 MHz
    #endif                              //  1 MHz / 2 =  500 kHz
    pADC->CTRLE = 15; // 15.5 without PGA, 16 with PGA, corresponding to 7.75 or 8 us.
 67a:	8f e0       	ldi	r24, 0x0F	; 15
 67c:	80 87       	std	Z+8, r24	; 0x08
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:1711
    pADC->CTRLA = ADC_ENABLE_bm | ADC_LOWLAT_bm;
 67e:	81 e2       	ldi	r24, 0x21	; 33
 680:	80 83       	st	Z, r24
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:1716
    /* Default low latency mode on
     * Users can turn it off if they care about power consumption while ADC is on
     * and chip is awake, since these parts don't have the perverse ADC-left-on
     * behavior of classic AVRs. */
    pADC->CTRLC = TIMEBASE_1US; // defined in Arduino.h.
 682:	80 e8       	ldi	r24, 0x80	; 128
 684:	82 83       	std	Z+2, r24	; 0x02
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:1717
    pADC->PGACTRL = ADC_PGABIASSEL_3_4X_gc | ADC_ADCPGASAMPDUR_15CLK_gc;
 686:	8a e0       	ldi	r24, 0x0A	; 10
 688:	83 87       	std	Z+11, r24	; 0x0b
init_TCA0():
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:1780
  /*  TYPE A TIMER   */
  #if !defined(TCA_BUFFERED_3PIN)
    #if defined(PORTMUX_CTRLC)
      PORTMUX.CTRLC = TCA_PORTMUX;
    #else
      PORTMUX.TCAROUTEA = TCA_PORTMUX;
 68a:	10 92 e4 05 	sts	0x05E4, r1	; 0x8005e4 <digital_pin_to_bit_mask+0x7f79b8>
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:1782
    #endif
    TCA0.SPLIT.CTRLD   = TCA_SPLIT_SPLITM_bm;
 68e:	81 e0       	ldi	r24, 0x01	; 1
 690:	80 93 03 0a 	sts	0x0A03, r24	; 0x800a03 <digital_pin_to_bit_mask+0x7f7dd7>
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:1783
    TCA0.SPLIT.LPER    = PWM_TIMER_PERIOD;
 694:	9e ef       	ldi	r25, 0xFE	; 254
 696:	90 93 26 0a 	sts	0x0A26, r25	; 0x800a26 <digital_pin_to_bit_mask+0x7f7dfa>
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:1784
    TCA0.SPLIT.HPER    = PWM_TIMER_PERIOD;
 69a:	90 93 27 0a 	sts	0x0A27, r25	; 0x800a27 <digital_pin_to_bit_mask+0x7f7dfb>
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:1785
    TCA0.SPLIT.CTRLA   = (TIMERA_PRESCALER_bm | TCA_SPLIT_ENABLE_bm);
 69e:	9b e0       	ldi	r25, 0x0B	; 11
 6a0:	90 93 00 0a 	sts	0x0A00, r25	; 0x800a00 <digital_pin_to_bit_mask+0x7f7dd4>
init_millis():
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:1447
        // RTC.CLKSEL=0; this is the power on value
      #endif
      RTC.INTCTRL         = 0x01; // enable overflow interrupt
      RTC.CTRLA           = (RTC_RUNSTDBY_bm|RTC_RTCEN_bm|RTC_PRESCALER_DIV32_gc);//fire it up, prescale by 32.
    #else // It's a type b timer - we have already errored out if that wasn't defined
      _timer->CCMP = TIME_TRACKING_TIMER_PERIOD;
 6a4:	2f e3       	ldi	r18, 0x3F	; 63
 6a6:	3f e1       	ldi	r19, 0x1F	; 31
 6a8:	20 93 9c 0a 	sts	0x0A9C, r18	; 0x800a9c <digital_pin_to_bit_mask+0x7f7e70>
 6ac:	30 93 9d 0a 	sts	0x0A9D, r19	; 0x800a9d <digital_pin_to_bit_mask+0x7f7e71>
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:1449
      // Enable timer interrupt, but clear the rest of register
      _timer->INTCTRL = TCB_CAPT_bm;
 6b0:	80 93 95 0a 	sts	0x0A95, r24	; 0x800a95 <digital_pin_to_bit_mask+0x7f7e69>
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:1451
      // Clear timer mode (since it will have been set as PWM by init())
      _timer->CTRLB = 0;
 6b4:	10 92 91 0a 	sts	0x0A91, r1	; 0x800a91 <digital_pin_to_bit_mask+0x7f7e65>
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/wiring.c:1453
      // CLK_PER/1 is 0b00, . CLK_PER/2 is 0b01, so bitwise OR of valid divider with enable works
      _timer->CTRLA = TIME_TRACKING_TIMER_DIVIDER|TCB_ENABLE_bm;  // Keep this last before enabling interrupts to ensure tracking as accurate as possible
 6b8:	83 e0       	ldi	r24, 0x03	; 3
 6ba:	80 93 90 0a 	sts	0x0A90, r24	; 0x800a90 <digital_pin_to_bit_mask+0x7f7e64>
main():
C:\Users\debra\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.10\cores\megatinycore/main.cpp:53
 * just waiting for the DU-series now                                                           */
int main() {
  onBeforeInit(); // Emnpty callback called before init but after the .init stuff. First normal code executed
  init(); // Interrupts are turned on just prior to init() returning.
  initVariant();
  if (!onAfterInit()) sei();  // enable interrupts.
 6be:	78 94       	sei
begin():
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:134

/*!
  @brief   Configure NeoPixel pin for output.
*/
void Adafruit_NeoPixel::begin(void) {
  if (pin >= 0) {
 6c0:	80 91 10 34 	lds	r24, 0x3410	; 0x803410 <strip+0x6>
 6c4:	90 91 11 34 	lds	r25, 0x3411	; 0x803411 <strip+0x7>
 6c8:	97 fd       	sbrc	r25, 7
 6ca:	05 c0       	rjmp	.+10     	; 0x6d6 <main+0x6e>
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:135
    pinMode(pin, OUTPUT);
 6cc:	61 e0       	ldi	r22, 0x01	; 1
 6ce:	8f df       	rcall	.-226    	; 0x5ee <pinMode>
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:136
    digitalWrite(pin, LOW);
 6d0:	80 91 10 34 	lds	r24, 0x3410	; 0x803410 <strip+0x6>
 6d4:	41 df       	rcall	.-382    	; 0x558 <digitalWrite.constprop.17>
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:138
  }
  begun = true;
 6d6:	81 e0       	ldi	r24, 0x01	; 1
 6d8:	80 93 0b 34 	sts	0x340B, r24	; 0x80340b <strip+0x1>
setBrightness():
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:3613
  // 8x8-bit multiply and taking the MSB. 'brightness' is a uint8_t,
  // adding 1 here may (intentionally) roll over...so 0 = max brightness
  // (color values are interpreted literally; no scaling), 1 = min
  // brightness (off), 255 = just below max brightness.
  uint8_t newBrightness = b + 1;
  if (newBrightness != brightness) { // Compare against prior value
 6dc:	60 91 12 34 	lds	r22, 0x3412	; 0x803412 <strip+0x8>
 6e0:	63 33       	cpi	r22, 0x33	; 51
 6e2:	29 f1       	breq	.+74     	; 0x72e <main+0xc6>
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:3624
    // and scale it (subsequent graphics commands also work at this
    // brightness level). If there's a significant step up in brightness,
    // the limited number of steps (quantization) in the old data will be
    // quite visible in the re-scaled version. For a non-destructive
    // change, you'll need to re-render the full strip data. C'est la vie.
    uint8_t c, *ptr = pixels,
 6e4:	20 91 13 34 	lds	r18, 0x3413	; 0x803413 <strip+0x9>
 6e8:	30 91 14 34 	lds	r19, 0x3414	; 0x803414 <strip+0xa>
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:3625
               oldBrightness = brightness - 1; // De-wrap old brightness value
 6ec:	61 50       	subi	r22, 0x01	; 1
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:3627
    uint16_t scale;
    if (oldBrightness == 0)
 6ee:	c9 f0       	breq	.+50     	; 0x722 <main+0xba>
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:3632
      scale = 0; // Avoid /0
    else if (b == 255)
      scale = 65535 / oldBrightness;
    else
      scale = (((uint16_t)newBrightness << 8) - 1) / oldBrightness;
 6f0:	70 e0       	ldi	r23, 0x00	; 0
 6f2:	8f ef       	ldi	r24, 0xFF	; 255
 6f4:	92 e3       	ldi	r25, 0x32	; 50
 6f6:	24 d1       	rcall	.+584    	; 0x940 <__udivmodhi4>
main():
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:3624
    // and scale it (subsequent graphics commands also work at this
    // brightness level). If there's a significant step up in brightness,
    // the limited number of steps (quantization) in the old data will be
    // quite visible in the re-scaled version. For a non-destructive
    // change, you'll need to re-render the full strip data. C'est la vie.
    uint8_t c, *ptr = pixels,
 6f8:	f9 01       	movw	r30, r18
setBrightness():
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:3633
      scale = 0; // Avoid /0
    else if (b == 255)
      scale = 65535 / oldBrightness;
    else
      scale = (((uint16_t)newBrightness << 8) - 1) / oldBrightness;
    for (uint16_t i = 0; i < numBytes; i++) {
 6fa:	40 91 0e 34 	lds	r20, 0x340E	; 0x80340e <strip+0x4>
 6fe:	50 91 0f 34 	lds	r21, 0x340F	; 0x80340f <strip+0x5>
 702:	cf 01       	movw	r24, r30
 704:	82 1b       	sub	r24, r18
 706:	93 0b       	sbc	r25, r19
 708:	84 17       	cp	r24, r20
 70a:	95 07       	cpc	r25, r21
 70c:	68 f4       	brcc	.+26     	; 0x728 <main+0xc0>
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:3635
      c = *ptr;
      *ptr++ = (c * scale) >> 8;
 70e:	df 01       	movw	r26, r30
 710:	4d 91       	ld	r20, X+
 712:	46 9f       	mul	r20, r22
 714:	c0 01       	movw	r24, r0
 716:	47 9f       	mul	r20, r23
 718:	90 0d       	add	r25, r0
 71a:	11 24       	eor	r1, r1
 71c:	90 83       	st	Z, r25
main():
 71e:	fd 01       	movw	r30, r26
 720:	ec cf       	rjmp	.-40     	; 0x6fa <main+0x92>
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:3628
    // change, you'll need to re-render the full strip data. C'est la vie.
    uint8_t c, *ptr = pixels,
               oldBrightness = brightness - 1; // De-wrap old brightness value
    uint16_t scale;
    if (oldBrightness == 0)
      scale = 0; // Avoid /0
 722:	70 e0       	ldi	r23, 0x00	; 0
 724:	60 e0       	ldi	r22, 0x00	; 0
 726:	e8 cf       	rjmp	.-48     	; 0x6f8 <main+0x90>
setBrightness():
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:3637
      scale = (((uint16_t)newBrightness << 8) - 1) / oldBrightness;
    for (uint16_t i = 0; i < numBytes; i++) {
      c = *ptr;
      *ptr++ = (c * scale) >> 8;
    }
    brightness = newBrightness;
 728:	83 e3       	ldi	r24, 0x33	; 51
 72a:	80 93 12 34 	sts	0x3412, r24	; 0x803412 <strip+0x8>
setup():
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:32
  #endif
  // End of trinket special code

  strip.begin();
  strip.setBrightness(50);
  strip.show(); // Initialize all pixels to 'off'
 72e:	71 dd       	rcall	.-1310   	; 0x212 <Adafruit_NeoPixel::show() [clone .constprop.9]>
theaterChaseRainbow():
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:108
//Theatre-style crawling lights with rainbow effect
void theaterChaseRainbow(uint8_t wait) {
  for (int j=0; j < 256; j++) {     // cycle all 256 colors in the wheel
    for (int q=0; q < 3; q++) {
      for (uint16_t i=0; i < strip.numPixels(); i=i+3) {
        strip.setPixelColor(i+q, Wheel( (i+j) % 255));    //turn every third pixel on
 730:	cc 24       	eor	r12, r12
 732:	ca 94       	dec	r12
 734:	d1 2c       	mov	r13, r1
loop():
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:37
  strip.show(); // Initialize all pixels to 'off'
}

void loop() {
  // Some example procedures showing how to display to the pixels:
  colorWipe(strip.Color(255, 0, 0), 50); // Red
 736:	60 e0       	ldi	r22, 0x00	; 0
 738:	70 e0       	ldi	r23, 0x00	; 0
 73a:	8f ef       	ldi	r24, 0xFF	; 255
 73c:	90 e0       	ldi	r25, 0x00	; 0
 73e:	5d de       	rcall	.-838    	; 0x3fa <colorWipe(unsigned long, unsigned char) [clone .constprop.4]>
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:38
  colorWipe(strip.Color(0, 255, 0), 50); // Green
 740:	60 e0       	ldi	r22, 0x00	; 0
 742:	7f ef       	ldi	r23, 0xFF	; 255
 744:	80 e0       	ldi	r24, 0x00	; 0
 746:	90 e0       	ldi	r25, 0x00	; 0
 748:	58 de       	rcall	.-848    	; 0x3fa <colorWipe(unsigned long, unsigned char) [clone .constprop.4]>
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:39
  colorWipe(strip.Color(0, 0, 255), 50); // Blue
 74a:	6f ef       	ldi	r22, 0xFF	; 255
 74c:	70 e0       	ldi	r23, 0x00	; 0
 74e:	80 e0       	ldi	r24, 0x00	; 0
 750:	90 e0       	ldi	r25, 0x00	; 0
 752:	53 de       	rcall	.-858    	; 0x3fa <colorWipe(unsigned long, unsigned char) [clone .constprop.4]>
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:42
//colorWipe(strip.Color(0, 0, 0, 255), 50); // White RGBW
  // Send a theater pixel chase in...
  theaterChase(strip.Color(127, 127, 127), 50); // White
 754:	6f e7       	ldi	r22, 0x7F	; 127
 756:	7f e7       	ldi	r23, 0x7F	; 127
 758:	8f e7       	ldi	r24, 0x7F	; 127
 75a:	90 e0       	ldi	r25, 0x00	; 0
 75c:	72 de       	rcall	.-796    	; 0x442 <theaterChase(unsigned long, unsigned char) [clone .constprop.3]>
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:43
  theaterChase(strip.Color(127, 0, 0), 50); // Red
 75e:	60 e0       	ldi	r22, 0x00	; 0
 760:	70 e0       	ldi	r23, 0x00	; 0
 762:	8f e7       	ldi	r24, 0x7F	; 127
 764:	90 e0       	ldi	r25, 0x00	; 0
 766:	6d de       	rcall	.-806    	; 0x442 <theaterChase(unsigned long, unsigned char) [clone .constprop.3]>
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:44
  theaterChase(strip.Color(0, 0, 127), 50); // Blue
 768:	6f e7       	ldi	r22, 0x7F	; 127
 76a:	70 e0       	ldi	r23, 0x00	; 0
 76c:	80 e0       	ldi	r24, 0x00	; 0
 76e:	90 e0       	ldi	r25, 0x00	; 0
 770:	68 de       	rcall	.-816    	; 0x442 <theaterChase(unsigned long, unsigned char) [clone .constprop.3]>
main():
 772:	10 e0       	ldi	r17, 0x00	; 0
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:63
}

void rainbow(uint8_t wait) {
  uint16_t i, j;

  for(j=0; j<256; j++) {
 774:	00 e0       	ldi	r16, 0x00	; 0
 776:	d0 e0       	ldi	r29, 0x00	; 0
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:64
    for(i=0; i<strip.numPixels(); i++) {
 778:	c0 e0       	ldi	r28, 0x00	; 0
rainbow():
 77a:	80 91 0c 34 	lds	r24, 0x340C	; 0x80340c <strip+0x2>
 77e:	90 91 0d 34 	lds	r25, 0x340D	; 0x80340d <strip+0x3>
 782:	c8 17       	cp	r28, r24
 784:	d9 07       	cpc	r29, r25
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:65
      strip.setPixelColor(i, Wheel((i+j) & 255));
 786:	48 f4       	brcc	.+18     	; 0x79a <main+0x132>
 788:	8c 2f       	mov	r24, r28
 78a:	80 0f       	add	r24, r16
 78c:	a9 de       	rcall	.-686    	; 0x4e0 <Wheel(unsigned char)>
 78e:	ab 01       	movw	r20, r22
 790:	bc 01       	movw	r22, r24
 792:	ce 01       	movw	r24, r28
 794:	a5 dc       	rcall	.-1718   	; 0xe0 <Adafruit_NeoPixel::setPixelColor(unsigned int, unsigned long) [clone .constprop.5]>
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:64

void rainbow(uint8_t wait) {
  uint16_t i, j;

  for(j=0; j<256; j++) {
    for(i=0; i<strip.numPixels(); i++) {
 796:	21 96       	adiw	r28, 0x01	; 1
 798:	f0 cf       	rjmp	.-32     	; 0x77a <main+0x112>
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:67
      strip.setPixelColor(i, Wheel((i+j) & 255));
    }
    strip.show();
 79a:	3b dd       	rcall	.-1418   	; 0x212 <Adafruit_NeoPixel::show() [clone .constprop.9]>
 79c:	64 e1       	ldi	r22, 0x14	; 20
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:68
    delay(wait);
 79e:	70 e0       	ldi	r23, 0x00	; 0
 7a0:	80 e0       	ldi	r24, 0x00	; 0
 7a2:	90 e0       	ldi	r25, 0x00	; 0
 7a4:	01 de       	rcall	.-1022   	; 0x3a8 <delay>
 7a6:	0f 5f       	subi	r16, 0xFF	; 255
 7a8:	1f 4f       	sbci	r17, 0xFF	; 255
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:63
}

void rainbow(uint8_t wait) {
  uint16_t i, j;

  for(j=0; j<256; j++) {
 7aa:	01 15       	cp	r16, r1
 7ac:	81 e0       	ldi	r24, 0x01	; 1
 7ae:	18 07       	cpc	r17, r24
 7b0:	11 f7       	brne	.-60     	; 0x776 <main+0x10e>
main():
 7b2:	d0 e0       	ldi	r29, 0x00	; 0
 7b4:	c0 e0       	ldi	r28, 0x00	; 0
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:76

// Slightly different, this makes the rainbow equally distributed throughout
void rainbowCycle(uint8_t wait) {
  uint16_t i, j;

  for(j=0; j<256*5; j++) { // 5 cycles of all colors on wheel
 7b6:	f1 2c       	mov	r15, r1
 7b8:	e1 2c       	mov	r14, r1
 7ba:	10 e0       	ldi	r17, 0x00	; 0
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:77
    for(i=0; i< strip.numPixels(); i++) {
 7bc:	00 e0       	ldi	r16, 0x00	; 0
 7be:	60 91 0c 34 	lds	r22, 0x340C	; 0x80340c <strip+0x2>
 7c2:	70 91 0d 34 	lds	r23, 0x340D	; 0x80340d <strip+0x3>
rainbowCycle():
 7c6:	06 17       	cp	r16, r22
 7c8:	17 07       	cpc	r17, r23
 7ca:	68 f4       	brcc	.+26     	; 0x7e6 <main+0x17e>
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:78
      strip.setPixelColor(i, Wheel(((i * 256 / strip.numPixels()) + j) & 255));
 7cc:	c7 01       	movw	r24, r14
 7ce:	b8 d0       	rcall	.+368    	; 0x940 <__udivmodhi4>
 7d0:	8c 2f       	mov	r24, r28
 7d2:	86 0f       	add	r24, r22
 7d4:	85 de       	rcall	.-758    	; 0x4e0 <Wheel(unsigned char)>
 7d6:	ab 01       	movw	r20, r22
 7d8:	bc 01       	movw	r22, r24
 7da:	c8 01       	movw	r24, r16
 7dc:	81 dc       	rcall	.-1790   	; 0xe0 <Adafruit_NeoPixel::setPixelColor(unsigned int, unsigned long) [clone .constprop.5]>
 7de:	0f 5f       	subi	r16, 0xFF	; 255
 7e0:	1f 4f       	sbci	r17, 0xFF	; 255
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:77
// Slightly different, this makes the rainbow equally distributed throughout
void rainbowCycle(uint8_t wait) {
  uint16_t i, j;

  for(j=0; j<256*5; j++) { // 5 cycles of all colors on wheel
    for(i=0; i< strip.numPixels(); i++) {
 7e2:	f3 94       	inc	r15
 7e4:	ec cf       	rjmp	.-40     	; 0x7be <main+0x156>
 7e6:	15 dd       	rcall	.-1494   	; 0x212 <Adafruit_NeoPixel::show() [clone .constprop.9]>
 7e8:	64 e1       	ldi	r22, 0x14	; 20
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:80
      strip.setPixelColor(i, Wheel(((i * 256 / strip.numPixels()) + j) & 255));
    }
    strip.show();
 7ea:	70 e0       	ldi	r23, 0x00	; 0
 7ec:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:81
    delay(wait);
 7ee:	90 e0       	ldi	r25, 0x00	; 0
 7f0:	db dd       	rcall	.-1098   	; 0x3a8 <delay>
 7f2:	21 96       	adiw	r28, 0x01	; 1
 7f4:	c1 15       	cp	r28, r1
 7f6:	85 e0       	ldi	r24, 0x05	; 5
 7f8:	d8 07       	cpc	r29, r24
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:76

// Slightly different, this makes the rainbow equally distributed throughout
void rainbowCycle(uint8_t wait) {
  uint16_t i, j;

  for(j=0; j<256*5; j++) { // 5 cycles of all colors on wheel
 7fa:	e9 f6       	brne	.-70     	; 0x7b6 <main+0x14e>
main():
 7fc:	f1 2c       	mov	r15, r1
 7fe:	e1 2c       	mov	r14, r1
 800:	d0 e0       	ldi	r29, 0x00	; 0
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:105
  }
}

//Theatre-style crawling lights with rainbow effect
void theaterChaseRainbow(uint8_t wait) {
  for (int j=0; j < 256; j++) {     // cycle all 256 colors in the wheel
 802:	c0 e0       	ldi	r28, 0x00	; 0
 804:	10 e0       	ldi	r17, 0x00	; 0
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:106
    for (int q=0; q < 3; q++) {
 806:	00 e0       	ldi	r16, 0x00	; 0
theaterChaseRainbow():
 808:	80 91 0c 34 	lds	r24, 0x340C	; 0x80340c <strip+0x2>
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:107
      for (uint16_t i=0; i < strip.numPixels(); i=i+3) {
 80c:	90 91 0d 34 	lds	r25, 0x340D	; 0x80340d <strip+0x3>
 810:	08 17       	cp	r16, r24
 812:	19 07       	cpc	r17, r25
 814:	78 f4       	brcc	.+30     	; 0x834 <main+0x1cc>
 816:	c7 01       	movw	r24, r14
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:108
        strip.setPixelColor(i+q, Wheel( (i+j) % 255));    //turn every third pixel on
 818:	80 0f       	add	r24, r16
 81a:	91 1f       	adc	r25, r17
 81c:	b6 01       	movw	r22, r12
 81e:	90 d0       	rcall	.+288    	; 0x940 <__udivmodhi4>
 820:	5f de       	rcall	.-834    	; 0x4e0 <Wheel(unsigned char)>
 822:	ab 01       	movw	r20, r22
 824:	bc 01       	movw	r22, r24
 826:	ce 01       	movw	r24, r28
 828:	80 0f       	add	r24, r16
 82a:	91 1f       	adc	r25, r17
 82c:	59 dc       	rcall	.-1870   	; 0xe0 <Adafruit_NeoPixel::setPixelColor(unsigned int, unsigned long) [clone .constprop.5]>
 82e:	0d 5f       	subi	r16, 0xFD	; 253
 830:	1f 4f       	sbci	r17, 0xFF	; 255
 832:	ea cf       	rjmp	.-44     	; 0x808 <main+0x1a0>
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:107

//Theatre-style crawling lights with rainbow effect
void theaterChaseRainbow(uint8_t wait) {
  for (int j=0; j < 256; j++) {     // cycle all 256 colors in the wheel
    for (int q=0; q < 3; q++) {
      for (uint16_t i=0; i < strip.numPixels(); i=i+3) {
 834:	ee dc       	rcall	.-1572   	; 0x212 <Adafruit_NeoPixel::show() [clone .constprop.9]>
 836:	62 e3       	ldi	r22, 0x32	; 50
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:110
        strip.setPixelColor(i+q, Wheel( (i+j) % 255));    //turn every third pixel on
      }
      strip.show();
 838:	70 e0       	ldi	r23, 0x00	; 0
 83a:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:112

      delay(wait);
 83c:	90 e0       	ldi	r25, 0x00	; 0
 83e:	b4 dd       	rcall	.-1176   	; 0x3a8 <delay>
main():
 840:	10 e0       	ldi	r17, 0x00	; 0
 842:	00 e0       	ldi	r16, 0x00	; 0
theaterChaseRainbow():
 844:	80 91 0c 34 	lds	r24, 0x340C	; 0x80340c <strip+0x2>
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:114

      for (uint16_t i=0; i < strip.numPixels(); i=i+3) {
 848:	90 91 0d 34 	lds	r25, 0x340D	; 0x80340d <strip+0x3>
 84c:	08 17       	cp	r16, r24
 84e:	19 07       	cpc	r17, r25
 850:	50 f4       	brcc	.+20     	; 0x866 <main+0x1fe>
 852:	40 e0       	ldi	r20, 0x00	; 0
 854:	50 e0       	ldi	r21, 0x00	; 0
 856:	ba 01       	movw	r22, r20
 858:	ce 01       	movw	r24, r28
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:115
        strip.setPixelColor(i+q, 0);        //turn every third pixel off
 85a:	80 0f       	add	r24, r16
 85c:	91 1f       	adc	r25, r17
 85e:	40 dc       	rcall	.-1920   	; 0xe0 <Adafruit_NeoPixel::setPixelColor(unsigned int, unsigned long) [clone .constprop.5]>
 860:	0d 5f       	subi	r16, 0xFD	; 253
 862:	1f 4f       	sbci	r17, 0xFF	; 255
 864:	ef cf       	rjmp	.-34     	; 0x844 <main+0x1dc>
 866:	21 96       	adiw	r28, 0x01	; 1
 868:	c3 30       	cpi	r28, 0x03	; 3
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:114
      }
      strip.show();

      delay(wait);

      for (uint16_t i=0; i < strip.numPixels(); i=i+3) {
 86a:	d1 05       	cpc	r29, r1
 86c:	59 f6       	brne	.-106    	; 0x804 <main+0x19c>
 86e:	8f ef       	ldi	r24, 0xFF	; 255
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:106
}

//Theatre-style crawling lights with rainbow effect
void theaterChaseRainbow(uint8_t wait) {
  for (int j=0; j < 256; j++) {     // cycle all 256 colors in the wheel
    for (int q=0; q < 3; q++) {
 870:	e8 1a       	sub	r14, r24
 872:	f8 0a       	sbc	r15, r24
 874:	e1 14       	cp	r14, r1
 876:	81 e0       	ldi	r24, 0x01	; 1
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:105
  }
}

//Theatre-style crawling lights with rainbow effect
void theaterChaseRainbow(uint8_t wait) {
  for (int j=0; j < 256; j++) {     // cycle all 256 colors in the wheel
 878:	f8 06       	cpc	r15, r24
 87a:	09 f0       	breq	.+2      	; 0x87e <main+0x216>
 87c:	c1 cf       	rjmp	.-126    	; 0x800 <main+0x198>
 87e:	5b cf       	rjmp	.-330    	; 0x736 <main+0xce>

00000880 <_GLOBAL__sub_I_strip>:
_GLOBAL__sub_I_strip():
 880:	10 92 0b 34 	sts	0x340B, r1	; 0x80340b <strip+0x1>
 884:	10 92 12 34 	sts	0x3412, r1	; 0x803412 <strip+0x8>
 888:	10 92 19 34 	sts	0x3419, r1	; 0x803419 <strip+0xf>
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:81
              with color bytes expressed in green, red, blue order per
              pixel.
  @return  Adafruit_NeoPixel object. Call the begin() function before use.
*/
Adafruit_NeoPixel::Adafruit_NeoPixel(uint16_t n, int16_t p, neoPixelType t)
    : begun(false), brightness(0), pixels(NULL), endTime(0) {
 88c:	10 92 1a 34 	sts	0x341A, r1	; 0x80341a <strip+0x10>
 890:	10 92 1b 34 	sts	0x341B, r1	; 0x80341b <strip+0x11>
 894:	10 92 1c 34 	sts	0x341C, r1	; 0x80341c <strip+0x12>
updateType():
 898:	81 e0       	ldi	r24, 0x01	; 1
 89a:	80 93 18 34 	sts	0x3418, r24	; 0x803418 <strip+0xe>
 89e:	80 93 15 34 	sts	0x3415, r24	; 0x803415 <strip+0xb>
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:184
           (length, pin, type).
*/
void Adafruit_NeoPixel::updateType(neoPixelType t) {
  bool oldThreeBytesPerPixel = (wOffset == rOffset); // false if RGBW

  wOffset = (t >> 6) & 0b11; // See notes in header file
 8a2:	10 92 16 34 	sts	0x3416, r1	; 0x803416 <strip+0xc>
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:185
  rOffset = (t >> 4) & 0b11; // regarding R/G/B/W offsets
 8a6:	92 e0       	ldi	r25, 0x02	; 2
 8a8:	90 93 17 34 	sts	0x3417, r25	; 0x803417 <strip+0xd>
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:186
  gOffset = (t >> 2) & 0b11;
 8ac:	80 93 0a 34 	sts	0x340A, r24	; 0x80340a <strip>
updateLength():
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:187
  bOffset = t & 0b11;
 8b0:	84 e2       	ldi	r24, 0x24	; 36
 8b2:	90 e0       	ldi	r25, 0x00	; 0
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:189
#if defined(NEO_KHZ400)
  is800KHz = (t < 256); // 400 KHz flag is 1<<8
 8b4:	80 93 0e 34 	sts	0x340E, r24	; 0x80340e <strip+0x4>
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:155
*/
void Adafruit_NeoPixel::updateLength(uint16_t n) {
  free(pixels); // Free existing data (if any)

  // Allocate new data -- note: ALL PIXELS ARE CLEARED
  numBytes = n * ((wOffset == rOffset) ? 3 : 4);
 8b8:	90 93 0f 34 	sts	0x340F, r25	; 0x80340f <strip+0x5>
 8bc:	74 d0       	rcall	.+232    	; 0x9a6 <malloc>
 8be:	80 93 13 34 	sts	0x3413, r24	; 0x803413 <strip+0x9>
 8c2:	90 93 14 34 	sts	0x3414, r25	; 0x803414 <strip+0xa>
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:156
  if ((pixels = (uint8_t *)malloc(numBytes))) {
 8c6:	00 97       	sbiw	r24, 0x00	; 0
 8c8:	21 f1       	breq	.+72     	; 0x912 <_GLOBAL__sub_I_strip+0x92>
 8ca:	24 e2       	ldi	r18, 0x24	; 36
 8cc:	fc 01       	movw	r30, r24
 8ce:	11 92       	st	Z+, r1
 8d0:	2a 95       	dec	r18
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:157
    memset(pixels, 0, numBytes);
 8d2:	e9 f7       	brne	.-6      	; 0x8ce <_GLOBAL__sub_I_strip+0x4e>
 8d4:	8c e0       	ldi	r24, 0x0C	; 12
 8d6:	90 e0       	ldi	r25, 0x00	; 0
 8d8:	80 93 0c 34 	sts	0x340C, r24	; 0x80340c <strip+0x2>
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:158
    numLEDs = n;
 8dc:	90 93 0d 34 	sts	0x340D, r25	; 0x80340d <strip+0x3>
setPin():
 8e0:	88 e0       	ldi	r24, 0x08	; 8
 8e2:	90 e0       	ldi	r25, 0x00	; 0
 8e4:	80 93 10 34 	sts	0x3410, r24	; 0x803410 <strip+0x6>
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:3295
  @param   p  Arduino pin number (-1 = no pin).
*/
void Adafruit_NeoPixel::setPin(int16_t p) {
  if (begun && (pin >= 0))
    pinMode(pin, INPUT); // Disable existing out pin
  pin = p;
 8e8:	90 93 11 34 	sts	0x3411, r25	; 0x803411 <strip+0x7>
 8ec:	80 91 0b 34 	lds	r24, 0x340B	; 0x80340b <strip+0x1>
 8f0:	88 23       	and	r24, r24
 8f2:	29 f0       	breq	.+10     	; 0x8fe <_GLOBAL__sub_I_strip+0x7e>
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:3296
  if (begun) {
 8f4:	61 e0       	ldi	r22, 0x01	; 1
 8f6:	88 e0       	ldi	r24, 0x08	; 8
 8f8:	7a de       	rcall	.-780    	; 0x5ee <pinMode>
 8fa:	88 e0       	ldi	r24, 0x08	; 8
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:3297
    pinMode(p, OUTPUT);
 8fc:	2d de       	rcall	.-934    	; 0x558 <digitalWrite.constprop.17>
 8fe:	84 e0       	ldi	r24, 0x04	; 4
 900:	94 e0       	ldi	r25, 0x04	; 4
 902:	80 93 1d 34 	sts	0x341D, r24	; 0x80341d <strip+0x13>
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:3298
    digitalWrite(p, LOW);
 906:	90 93 1e 34 	sts	0x341E, r25	; 0x80341e <strip+0x14>
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:3301
  }
#if defined(__AVR__)
  port = portOutputRegister(digitalPinToPort(p));
 90a:	82 e0       	ldi	r24, 0x02	; 2
 90c:	80 93 1f 34 	sts	0x341F, r24	; 0x80341f <strip+0x15>
_GLOBAL__sub_I_strip():
 910:	08 95       	ret
updateLength():
 912:	10 92 0e 34 	sts	0x340E, r1	; 0x80340e <strip+0x4>
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:3302
  pinMask = digitalPinToBitMask(p);
 916:	10 92 0f 34 	sts	0x340F, r1	; 0x80340f <strip+0x5>
 91a:	10 92 0c 34 	sts	0x340C, r1	; 0x80340c <strip+0x2>
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:160
  numBytes = n * ((wOffset == rOffset) ? 3 : 4);
  if ((pixels = (uint8_t *)malloc(numBytes))) {
    memset(pixels, 0, numBytes);
    numLEDs = n;
  } else {
    numLEDs = numBytes = 0;
 91e:	10 92 0d 34 	sts	0x340D, r1	; 0x80340d <strip+0x3>
 922:	de cf       	rjmp	.-68     	; 0x8e0 <_GLOBAL__sub_I_strip+0x60>

00000924 <_GLOBAL__sub_D_strip>:
_GLOBAL__sub_D_strip():
 924:	80 91 13 34 	lds	r24, 0x3413	; 0x803413 <strip+0x9>
 928:	90 91 14 34 	lds	r25, 0x3414	; 0x803414 <strip+0xa>
 92c:	d8 d0       	rcall	.+432    	; 0xade <free>
 92e:	80 91 10 34 	lds	r24, 0x3410	; 0x803410 <strip+0x6>
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:126
/*!
  @brief   Deallocate Adafruit_NeoPixel object, set data pin back to INPUT.
*/
Adafruit_NeoPixel::~Adafruit_NeoPixel() {
  free(pixels);
  if (pin >= 0)
 932:	90 91 11 34 	lds	r25, 0x3411	; 0x803411 <strip+0x7>
 936:	97 fd       	sbrc	r25, 7
 938:	02 c0       	rjmp	.+4      	; 0x93e <_GLOBAL__sub_D_strip+0x1a>
c:\Users\debra\Dropbox\Documents\Arduino\libraries\Adafruit_NeoPixel/Adafruit_NeoPixel.cpp:127
    pinMode(pin, INPUT);
 93a:	60 e0       	ldi	r22, 0x00	; 0
 93c:	58 ce       	rjmp	.-848    	; 0x5ee <pinMode>
C:\Users\debra\Dropbox\Documents\Arduino\strandtest_wheel/strandtest_wheel.ino:134
    WheelPos -= 85;
    return strip.Color(0, WheelPos * 3, 255 - WheelPos * 3);
  }
  WheelPos -= 170;
  return strip.Color(WheelPos * 3, 255 - WheelPos * 3, 0);
}
 93e:	08 95       	ret

00000940 <__udivmodhi4>:
__udivmodhi4():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1408
 940:	aa 1b       	sub	r26, r26
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1409
 942:	bb 1b       	sub	r27, r27
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1410
 944:	51 e1       	ldi	r21, 0x11	; 17
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1411
 946:	07 c0       	rjmp	.+14     	; 0x956 <__udivmodhi4_ep>

00000948 <__udivmodhi4_loop>:
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1413
 948:	aa 1f       	adc	r26, r26
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1414
 94a:	bb 1f       	adc	r27, r27
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1415
 94c:	a6 17       	cp	r26, r22
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1416
 94e:	b7 07       	cpc	r27, r23
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1417
 950:	10 f0       	brcs	.+4      	; 0x956 <__udivmodhi4_ep>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1418
 952:	a6 1b       	sub	r26, r22
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1419
 954:	b7 0b       	sbc	r27, r23

00000956 <__udivmodhi4_ep>:
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1421
 956:	88 1f       	adc	r24, r24
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1422
 958:	99 1f       	adc	r25, r25
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1423
 95a:	5a 95       	dec	r21
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1424
 95c:	a9 f7       	brne	.-22     	; 0x948 <__udivmodhi4_loop>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1425
 95e:	80 95       	com	r24
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1426
 960:	90 95       	com	r25
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1428
 962:	bc 01       	movw	r22, r24
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1430
 964:	cd 01       	movw	r24, r26
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1432
 966:	08 95       	ret

00000968 <__muluhisi3>:
__muluhisi3():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:626
 968:	0f d0       	rcall	.+30     	; 0x988 <__umulhisi3>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:627
 96a:	a5 9f       	mul	r26, r21
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:628
 96c:	90 0d       	add	r25, r0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:629
 96e:	b4 9f       	mul	r27, r20
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:630
 970:	90 0d       	add	r25, r0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:631
 972:	a4 9f       	mul	r26, r20
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:632
 974:	80 0d       	add	r24, r0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:633
 976:	91 1d       	adc	r25, r1
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:634
 978:	11 24       	eor	r1, r1
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:635
 97a:	08 95       	ret

0000097c <__tablejump2__>:
__tablejump2__():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2296
 97c:	ee 0f       	add	r30, r30
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2297
 97e:	ff 1f       	adc	r31, r31
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2328
 980:	05 90       	lpm	r0, Z+
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2329
 982:	f4 91       	lpm	r31, Z
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2330
 984:	e0 2d       	mov	r30, r0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2331
 986:	09 94       	ijmp

00000988 <__umulhisi3>:
__umulhisi3():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:564
 988:	a2 9f       	mul	r26, r18
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:565
 98a:	b0 01       	movw	r22, r0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:566
 98c:	b3 9f       	mul	r27, r19
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:567
 98e:	c0 01       	movw	r24, r0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:568
 990:	a3 9f       	mul	r26, r19
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:573
 992:	70 0d       	add	r23, r0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:574
 994:	81 1d       	adc	r24, r1
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:575
 996:	11 24       	eor	r1, r1
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:576
 998:	91 1d       	adc	r25, r1
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:580
 99a:	b2 9f       	mul	r27, r18
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:581
 99c:	70 0d       	add	r23, r0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:582
 99e:	81 1d       	adc	r24, r1
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:583
 9a0:	11 24       	eor	r1, r1
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:584
 9a2:	91 1d       	adc	r25, r1
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:585
 9a4:	08 95       	ret

000009a6 <malloc>:
malloc():
 9a6:	0f 93       	push	r16
 9a8:	1f 93       	push	r17
 9aa:	cf 93       	push	r28
 9ac:	df 93       	push	r29
 9ae:	82 30       	cpi	r24, 0x02	; 2
 9b0:	91 05       	cpc	r25, r1
 9b2:	10 f4       	brcc	.+4      	; 0x9b8 <malloc+0x12>
 9b4:	82 e0       	ldi	r24, 0x02	; 2
 9b6:	90 e0       	ldi	r25, 0x00	; 0
 9b8:	e0 91 22 34 	lds	r30, 0x3422	; 0x803422 <__flp>
 9bc:	f0 91 23 34 	lds	r31, 0x3423	; 0x803423 <__flp+0x1>
 9c0:	30 e0       	ldi	r19, 0x00	; 0
 9c2:	20 e0       	ldi	r18, 0x00	; 0
 9c4:	b0 e0       	ldi	r27, 0x00	; 0
 9c6:	a0 e0       	ldi	r26, 0x00	; 0
 9c8:	30 97       	sbiw	r30, 0x00	; 0
 9ca:	99 f4       	brne	.+38     	; 0x9f2 <malloc+0x4c>
 9cc:	21 15       	cp	r18, r1
 9ce:	31 05       	cpc	r19, r1
 9d0:	09 f4       	brne	.+2      	; 0x9d4 <malloc+0x2e>
 9d2:	4a c0       	rjmp	.+148    	; 0xa68 <malloc+0xc2>
 9d4:	28 1b       	sub	r18, r24
 9d6:	39 0b       	sbc	r19, r25
 9d8:	24 30       	cpi	r18, 0x04	; 4
 9da:	31 05       	cpc	r19, r1
 9dc:	d8 f5       	brcc	.+118    	; 0xa54 <malloc+0xae>
 9de:	8a 81       	ldd	r24, Y+2	; 0x02
 9e0:	9b 81       	ldd	r25, Y+3	; 0x03
 9e2:	61 15       	cp	r22, r1
 9e4:	71 05       	cpc	r23, r1
 9e6:	89 f1       	breq	.+98     	; 0xa4a <malloc+0xa4>
 9e8:	fb 01       	movw	r30, r22
 9ea:	82 83       	std	Z+2, r24	; 0x02
 9ec:	93 83       	std	Z+3, r25	; 0x03
 9ee:	fe 01       	movw	r30, r28
 9f0:	11 c0       	rjmp	.+34     	; 0xa14 <malloc+0x6e>
 9f2:	40 81       	ld	r20, Z
 9f4:	51 81       	ldd	r21, Z+1	; 0x01
 9f6:	02 81       	ldd	r16, Z+2	; 0x02
 9f8:	13 81       	ldd	r17, Z+3	; 0x03
 9fa:	48 17       	cp	r20, r24
 9fc:	59 07       	cpc	r21, r25
 9fe:	e0 f0       	brcs	.+56     	; 0xa38 <malloc+0x92>
 a00:	48 17       	cp	r20, r24
 a02:	59 07       	cpc	r21, r25
 a04:	99 f4       	brne	.+38     	; 0xa2c <malloc+0x86>
 a06:	10 97       	sbiw	r26, 0x00	; 0
 a08:	61 f0       	breq	.+24     	; 0xa22 <malloc+0x7c>
 a0a:	12 96       	adiw	r26, 0x02	; 2
 a0c:	0c 93       	st	X, r16
 a0e:	12 97       	sbiw	r26, 0x02	; 2
 a10:	13 96       	adiw	r26, 0x03	; 3
 a12:	1c 93       	st	X, r17
 a14:	32 96       	adiw	r30, 0x02	; 2
 a16:	cf 01       	movw	r24, r30
 a18:	df 91       	pop	r29
 a1a:	cf 91       	pop	r28
 a1c:	1f 91       	pop	r17
 a1e:	0f 91       	pop	r16
 a20:	08 95       	ret
 a22:	00 93 22 34 	sts	0x3422, r16	; 0x803422 <__flp>
 a26:	10 93 23 34 	sts	0x3423, r17	; 0x803423 <__flp+0x1>
 a2a:	f4 cf       	rjmp	.-24     	; 0xa14 <malloc+0x6e>
 a2c:	21 15       	cp	r18, r1
 a2e:	31 05       	cpc	r19, r1
 a30:	51 f0       	breq	.+20     	; 0xa46 <malloc+0xa0>
 a32:	42 17       	cp	r20, r18
 a34:	53 07       	cpc	r21, r19
 a36:	38 f0       	brcs	.+14     	; 0xa46 <malloc+0xa0>
 a38:	a9 01       	movw	r20, r18
 a3a:	db 01       	movw	r26, r22
 a3c:	9a 01       	movw	r18, r20
 a3e:	bd 01       	movw	r22, r26
 a40:	df 01       	movw	r26, r30
 a42:	f8 01       	movw	r30, r16
 a44:	c1 cf       	rjmp	.-126    	; 0x9c8 <malloc+0x22>
 a46:	ef 01       	movw	r28, r30
 a48:	f9 cf       	rjmp	.-14     	; 0xa3c <malloc+0x96>
 a4a:	80 93 22 34 	sts	0x3422, r24	; 0x803422 <__flp>
 a4e:	90 93 23 34 	sts	0x3423, r25	; 0x803423 <__flp+0x1>
 a52:	cd cf       	rjmp	.-102    	; 0x9ee <malloc+0x48>
 a54:	fe 01       	movw	r30, r28
 a56:	e2 0f       	add	r30, r18
 a58:	f3 1f       	adc	r31, r19
 a5a:	81 93       	st	Z+, r24
 a5c:	91 93       	st	Z+, r25
 a5e:	22 50       	subi	r18, 0x02	; 2
 a60:	31 09       	sbc	r19, r1
 a62:	28 83       	st	Y, r18
 a64:	39 83       	std	Y+1, r19	; 0x01
 a66:	d7 cf       	rjmp	.-82     	; 0xa16 <malloc+0x70>
 a68:	20 91 20 34 	lds	r18, 0x3420	; 0x803420 <__brkval>
 a6c:	30 91 21 34 	lds	r19, 0x3421	; 0x803421 <__brkval+0x1>
 a70:	23 2b       	or	r18, r19
 a72:	41 f4       	brne	.+16     	; 0xa84 <malloc+0xde>
 a74:	20 91 02 34 	lds	r18, 0x3402	; 0x803402 <__malloc_heap_start>
 a78:	30 91 03 34 	lds	r19, 0x3403	; 0x803403 <__malloc_heap_start+0x1>
 a7c:	20 93 20 34 	sts	0x3420, r18	; 0x803420 <__brkval>
 a80:	30 93 21 34 	sts	0x3421, r19	; 0x803421 <__brkval+0x1>
 a84:	20 91 00 34 	lds	r18, 0x3400	; 0x803400 <__DATA_REGION_ORIGIN__>
 a88:	30 91 01 34 	lds	r19, 0x3401	; 0x803401 <__DATA_REGION_ORIGIN__+0x1>
 a8c:	21 15       	cp	r18, r1
 a8e:	31 05       	cpc	r19, r1
 a90:	41 f4       	brne	.+16     	; 0xaa2 <malloc+0xfc>
 a92:	2d b7       	in	r18, 0x3d	; 61
 a94:	3e b7       	in	r19, 0x3e	; 62
 a96:	40 91 04 34 	lds	r20, 0x3404	; 0x803404 <__malloc_margin>
 a9a:	50 91 05 34 	lds	r21, 0x3405	; 0x803405 <__malloc_margin+0x1>
 a9e:	24 1b       	sub	r18, r20
 aa0:	35 0b       	sbc	r19, r21
 aa2:	e0 91 20 34 	lds	r30, 0x3420	; 0x803420 <__brkval>
 aa6:	f0 91 21 34 	lds	r31, 0x3421	; 0x803421 <__brkval+0x1>
 aaa:	e2 17       	cp	r30, r18
 aac:	f3 07       	cpc	r31, r19
 aae:	a0 f4       	brcc	.+40     	; 0xad8 <malloc+0x132>
 ab0:	2e 1b       	sub	r18, r30
 ab2:	3f 0b       	sbc	r19, r31
 ab4:	28 17       	cp	r18, r24
 ab6:	39 07       	cpc	r19, r25
 ab8:	78 f0       	brcs	.+30     	; 0xad8 <malloc+0x132>
 aba:	ac 01       	movw	r20, r24
 abc:	4e 5f       	subi	r20, 0xFE	; 254
 abe:	5f 4f       	sbci	r21, 0xFF	; 255
 ac0:	24 17       	cp	r18, r20
 ac2:	35 07       	cpc	r19, r21
 ac4:	48 f0       	brcs	.+18     	; 0xad8 <malloc+0x132>
 ac6:	4e 0f       	add	r20, r30
 ac8:	5f 1f       	adc	r21, r31
 aca:	40 93 20 34 	sts	0x3420, r20	; 0x803420 <__brkval>
 ace:	50 93 21 34 	sts	0x3421, r21	; 0x803421 <__brkval+0x1>
 ad2:	81 93       	st	Z+, r24
 ad4:	91 93       	st	Z+, r25
 ad6:	9f cf       	rjmp	.-194    	; 0xa16 <malloc+0x70>
 ad8:	f0 e0       	ldi	r31, 0x00	; 0
 ada:	e0 e0       	ldi	r30, 0x00	; 0
 adc:	9c cf       	rjmp	.-200    	; 0xa16 <malloc+0x70>

00000ade <free>:
free():
 ade:	cf 93       	push	r28
 ae0:	df 93       	push	r29
 ae2:	00 97       	sbiw	r24, 0x00	; 0
 ae4:	e9 f0       	breq	.+58     	; 0xb20 <free+0x42>
 ae6:	fc 01       	movw	r30, r24
 ae8:	32 97       	sbiw	r30, 0x02	; 2
 aea:	12 82       	std	Z+2, r1	; 0x02
 aec:	13 82       	std	Z+3, r1	; 0x03
 aee:	a0 91 22 34 	lds	r26, 0x3422	; 0x803422 <__flp>
 af2:	b0 91 23 34 	lds	r27, 0x3423	; 0x803423 <__flp+0x1>
 af6:	ed 01       	movw	r28, r26
 af8:	30 e0       	ldi	r19, 0x00	; 0
 afa:	20 e0       	ldi	r18, 0x00	; 0
 afc:	10 97       	sbiw	r26, 0x00	; 0
 afe:	a1 f4       	brne	.+40     	; 0xb28 <free+0x4a>
 b00:	20 81       	ld	r18, Z
 b02:	31 81       	ldd	r19, Z+1	; 0x01
 b04:	82 0f       	add	r24, r18
 b06:	93 1f       	adc	r25, r19
 b08:	20 91 20 34 	lds	r18, 0x3420	; 0x803420 <__brkval>
 b0c:	30 91 21 34 	lds	r19, 0x3421	; 0x803421 <__brkval+0x1>
 b10:	28 17       	cp	r18, r24
 b12:	39 07       	cpc	r19, r25
 b14:	09 f0       	breq	.+2      	; 0xb18 <free+0x3a>
 b16:	61 c0       	rjmp	.+194    	; 0xbda <free+0xfc>
 b18:	e0 93 20 34 	sts	0x3420, r30	; 0x803420 <__brkval>
 b1c:	f0 93 21 34 	sts	0x3421, r31	; 0x803421 <__brkval+0x1>
 b20:	df 91       	pop	r29
 b22:	cf 91       	pop	r28
 b24:	08 95       	ret
 b26:	ea 01       	movw	r28, r20
 b28:	ce 17       	cp	r28, r30
 b2a:	df 07       	cpc	r29, r31
 b2c:	e8 f5       	brcc	.+122    	; 0xba8 <free+0xca>
 b2e:	4a 81       	ldd	r20, Y+2	; 0x02
 b30:	5b 81       	ldd	r21, Y+3	; 0x03
 b32:	9e 01       	movw	r18, r28
 b34:	41 15       	cp	r20, r1
 b36:	51 05       	cpc	r21, r1
 b38:	b1 f7       	brne	.-20     	; 0xb26 <free+0x48>
 b3a:	e9 01       	movw	r28, r18
 b3c:	ea 83       	std	Y+2, r30	; 0x02
 b3e:	fb 83       	std	Y+3, r31	; 0x03
 b40:	49 91       	ld	r20, Y+
 b42:	59 91       	ld	r21, Y+
 b44:	c4 0f       	add	r28, r20
 b46:	d5 1f       	adc	r29, r21
 b48:	ec 17       	cp	r30, r28
 b4a:	fd 07       	cpc	r31, r29
 b4c:	61 f4       	brne	.+24     	; 0xb66 <free+0x88>
 b4e:	80 81       	ld	r24, Z
 b50:	91 81       	ldd	r25, Z+1	; 0x01
 b52:	02 96       	adiw	r24, 0x02	; 2
 b54:	84 0f       	add	r24, r20
 b56:	95 1f       	adc	r25, r21
 b58:	e9 01       	movw	r28, r18
 b5a:	88 83       	st	Y, r24
 b5c:	99 83       	std	Y+1, r25	; 0x01
 b5e:	82 81       	ldd	r24, Z+2	; 0x02
 b60:	93 81       	ldd	r25, Z+3	; 0x03
 b62:	8a 83       	std	Y+2, r24	; 0x02
 b64:	9b 83       	std	Y+3, r25	; 0x03
 b66:	f0 e0       	ldi	r31, 0x00	; 0
 b68:	e0 e0       	ldi	r30, 0x00	; 0
 b6a:	12 96       	adiw	r26, 0x02	; 2
 b6c:	8d 91       	ld	r24, X+
 b6e:	9c 91       	ld	r25, X
 b70:	13 97       	sbiw	r26, 0x03	; 3
 b72:	00 97       	sbiw	r24, 0x00	; 0
 b74:	b9 f5       	brne	.+110    	; 0xbe4 <free+0x106>
 b76:	2d 91       	ld	r18, X+
 b78:	3c 91       	ld	r19, X
 b7a:	11 97       	sbiw	r26, 0x01	; 1
 b7c:	cd 01       	movw	r24, r26
 b7e:	02 96       	adiw	r24, 0x02	; 2
 b80:	82 0f       	add	r24, r18
 b82:	93 1f       	adc	r25, r19
 b84:	20 91 20 34 	lds	r18, 0x3420	; 0x803420 <__brkval>
 b88:	30 91 21 34 	lds	r19, 0x3421	; 0x803421 <__brkval+0x1>
 b8c:	28 17       	cp	r18, r24
 b8e:	39 07       	cpc	r19, r25
 b90:	39 f6       	brne	.-114    	; 0xb20 <free+0x42>
 b92:	30 97       	sbiw	r30, 0x00	; 0
 b94:	51 f5       	brne	.+84     	; 0xbea <free+0x10c>
 b96:	10 92 22 34 	sts	0x3422, r1	; 0x803422 <__flp>
 b9a:	10 92 23 34 	sts	0x3423, r1	; 0x803423 <__flp+0x1>
 b9e:	a0 93 20 34 	sts	0x3420, r26	; 0x803420 <__brkval>
 ba2:	b0 93 21 34 	sts	0x3421, r27	; 0x803421 <__brkval+0x1>
 ba6:	bc cf       	rjmp	.-136    	; 0xb20 <free+0x42>
 ba8:	c2 83       	std	Z+2, r28	; 0x02
 baa:	d3 83       	std	Z+3, r29	; 0x03
 bac:	40 81       	ld	r20, Z
 bae:	51 81       	ldd	r21, Z+1	; 0x01
 bb0:	84 0f       	add	r24, r20
 bb2:	95 1f       	adc	r25, r21
 bb4:	c8 17       	cp	r28, r24
 bb6:	d9 07       	cpc	r29, r25
 bb8:	61 f4       	brne	.+24     	; 0xbd2 <free+0xf4>
 bba:	4e 5f       	subi	r20, 0xFE	; 254
 bbc:	5f 4f       	sbci	r21, 0xFF	; 255
 bbe:	88 81       	ld	r24, Y
 bc0:	99 81       	ldd	r25, Y+1	; 0x01
 bc2:	48 0f       	add	r20, r24
 bc4:	59 1f       	adc	r21, r25
 bc6:	40 83       	st	Z, r20
 bc8:	51 83       	std	Z+1, r21	; 0x01
 bca:	8a 81       	ldd	r24, Y+2	; 0x02
 bcc:	9b 81       	ldd	r25, Y+3	; 0x03
 bce:	82 83       	std	Z+2, r24	; 0x02
 bd0:	93 83       	std	Z+3, r25	; 0x03
 bd2:	21 15       	cp	r18, r1
 bd4:	31 05       	cpc	r19, r1
 bd6:	09 f0       	breq	.+2      	; 0xbda <free+0xfc>
 bd8:	b0 cf       	rjmp	.-160    	; 0xb3a <free+0x5c>
 bda:	e0 93 22 34 	sts	0x3422, r30	; 0x803422 <__flp>
 bde:	f0 93 23 34 	sts	0x3423, r31	; 0x803423 <__flp+0x1>
 be2:	9e cf       	rjmp	.-196    	; 0xb20 <free+0x42>
 be4:	fd 01       	movw	r30, r26
 be6:	dc 01       	movw	r26, r24
 be8:	c0 cf       	rjmp	.-128    	; 0xb6a <free+0x8c>
 bea:	12 82       	std	Z+2, r1	; 0x02
 bec:	13 82       	std	Z+3, r1	; 0x03
 bee:	d7 cf       	rjmp	.-82     	; 0xb9e <free+0xc0>

00000bf0 <__do_global_dtors>:
__do_global_dtors():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2496
 bf0:	10 e0       	ldi	r17, 0x00	; 0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2497
 bf2:	cd e3       	ldi	r28, 0x3D	; 61
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2498
 bf4:	d0 e0       	ldi	r29, 0x00	; 0
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2502
 bf6:	03 c0       	rjmp	.+6      	; 0xbfe <__do_global_dtors+0xe>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2508
 bf8:	fe 01       	movw	r30, r28
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2509
 bfa:	c0 de       	rcall	.-640    	; 0x97c <__tablejump2__>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2510
 bfc:	21 96       	adiw	r28, 0x01	; 1
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2515
 bfe:	ce 33       	cpi	r28, 0x3E	; 62
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2516
 c00:	d1 07       	cpc	r29, r17
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2521
 c02:	d1 f7       	brne	.-12     	; 0xbf8 <__do_global_dtors+0x8>
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2278
 c04:	f8 94       	cli

00000c06 <__stop_program>:
__stop_program():
/home/admin/Arduino/toolchain-avr-special-master/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2280
 c06:	ff cf       	rjmp	.-2      	; 0xc06 <__stop_program>
